<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>XS-4 Terrain Scanner</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');
    
    :root {
      --bottom-panel-height: 115px;
      --hud-color: #E8A87C;
      --hud-title-color: #8B2942;
      --hud-label-color: #DEB8A0;
      --hud-value-color: #00FFFF;
      --safe-area-bottom: env(safe-area-inset-bottom, 0px);
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; overflow: hidden; }
    
    body { 
      background: #0a0a0a; 
      font-family: 'Share Tech Mono', monospace; 
      touch-action: manipulation;
      -webkit-touch-callout: none; 
      -webkit-user-select: none; 
      user-select: none;
      overscroll-behavior: none;
    }
    
    #canvas-container { 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: calc(var(--bottom-panel-height) + var(--safe-area-bottom));
      min-height: 0;
    }
    
    canvas { 
      display: block; 
      width: 100% !important; 
      height: 100% !important;
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .bottom-panel { 
      position: fixed; 
      bottom: 0; 
      left: 0; 
      right: 0; 
      height: calc(var(--bottom-panel-height) + var(--safe-area-bottom));
      padding-bottom: var(--safe-area-bottom);
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%); 
      border-top: 2px solid #333; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      z-index: 102; 
      padding-top: 12px;
      transform: translateZ(0);
    }
    
    .button-container { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .action-controls { display: flex; gap: 12px; justify-content: center; align-items: center; }
    
    .hud { 
      position: fixed; 
      color: var(--hud-title-color); 
      font-size: 13px; 
      text-transform: uppercase; 
      letter-spacing: 2px; 
      pointer-events: none; 
      text-shadow: 0 0 8px rgba(0,0,0,0.8); 
      background: rgba(0,0,0,0.4);
      padding: 15px; 
      border-radius: 8px; 
      z-index: 101;
      transform: translateZ(0);
    }
    
    .hud-top-left { top: 20px; left: 20px; }
    .hud-top-right { top: 20px; right: 20px; text-align: right; }
    .hud-bottom-left { bottom: calc(var(--bottom-panel-height) + 15px + var(--safe-area-bottom)); left: 20px; }
    
    .title { font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700; margin-bottom: 10px; color: var(--hud-title-color); }
    .data-row { margin: 5px 0; }
    .label { color: var(--hud-label-color); font-weight: 600; }
    .value { color: var(--hud-value-color); font-weight: 700; }
    
    .scanline { position: fixed; inset: 0; pointer-events: none; z-index: 100; display: none; }
    @media (min-width: 769px) {
      .scanline { display: block; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.003) 2px, rgba(0,0,0,0.003) 4px); }
    }
    
    .theme-controls { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; align-items: center; padding: 0 10px; }
    
    .theme-btn { 
      padding: 14px 24px; 
      font-family: 'Share Tech Mono', monospace; 
      font-size: 13px; 
      text-transform: uppercase; 
      letter-spacing: 2px; 
      border: 2px solid; 
      background: rgba(0,0,0,0.5); 
      cursor: pointer; 
      transition: all 0.3s ease; 
      font-weight: 700; 
      border-radius: 4px; 
      white-space: nowrap;
      min-height: 48px;
      min-width: 48px;
      -webkit-tap-highlight-color: transparent;
    }
    
    .theme-btn.desert { border-color: #E8A87C; color: #E8A87C; }
    .theme-btn.jungle { border-color: #39FF14; color: #39FF14; }
    .theme-btn.arctic { border-color: #7FFFD4; color: #7FFFD4; }
    
    .theme-btn.barrel-roll { 
      border-color: #FF2A2A; 
      color: #FFD700;
      background: linear-gradient(135deg, rgba(255,42,42,0.15) 0%, rgba(0,0,0,0.7) 50%, rgba(255,215,0,0.1) 100%);
      text-shadow: 0 0 10px rgba(255,215,0,0.9);
      box-shadow: inset 0 0 20px rgba(255,42,42,0.2), 0 0 15px rgba(255,42,42,0.4);
    }
    
    .theme-btn.scan-btn {
      border-color: #00FF88;
      color: #00FF88;
      background: linear-gradient(135deg, rgba(0,255,136,0.1) 0%, rgba(0,0,0,0.7) 50%, rgba(0,255,136,0.05) 100%);
      text-shadow: 0 0 10px rgba(0,255,136,0.9);
      box-shadow: inset 0 0 15px rgba(0,255,136,0.15), 0 0 12px rgba(0,255,136,0.3);
    }
    
    .theme-btn.scan-btn.scanning {
      animation: scan-pulse 0.5s ease-in-out infinite;
      pointer-events: none;
    }
    
    @keyframes scan-pulse {
      0%, 100% { box-shadow: inset 0 0 15px rgba(0,255,136,0.15), 0 0 12px rgba(0,255,136,0.3); }
      50% { box-shadow: inset 0 0 25px rgba(0,255,136,0.4), 0 0 25px rgba(0,255,136,0.6); }
    }
    
    .theme-btn:active { transform: scale(0.98); }
    .theme-btn.active { transform: scale(1.05); background: rgba(255,255,255,0.2); box-shadow: 0 0 20px currentColor; }
    
    /* SCAN REPORT - Compact floating panel that doesn't block view */
    .scan-report {
      position: fixed;
      top: 15px;
      right: 15px;
      transform: translateX(calc(100% + 20px)) scale(0.95);
      background: rgba(0,15,10,0.85);
      border: 1px solid rgba(0,255,136,0.5);
      border-radius: 8px;
      width: 280px;
      max-height: calc(100vh - var(--bottom-panel-height) - 40px - var(--safe-area-bottom));
      overflow: hidden;
      z-index: 150;
      opacity: 0;
      pointer-events: none;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      box-shadow: 0 0 25px rgba(0,255,136,0.25);
    }
    
    .scan-report.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateX(0) scale(1);
    }
    
    .scan-report.fading-out {
      opacity: 0;
      transform: translateX(calc(100% + 20px)) scale(0.95);
      transition: all 0.3s ease-in;
    }
    
    .scan-report-header {
      background: linear-gradient(90deg, rgba(0,255,136,0.2), transparent);
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,255,136,0.3);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .scan-report-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 11px;
      color: #00FF88;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-shadow: 0 0 8px rgba(0,255,136,0.8);
    }
    
    .scan-report-content {
      padding: 12px;
      max-height: calc(100vh - var(--bottom-panel-height) - 100px - var(--safe-area-bottom));
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(0,255,136,0.3) transparent;
    }
    
    .scan-report-content::-webkit-scrollbar { width: 3px; }
    .scan-report-content::-webkit-scrollbar-track { background: transparent; }
    .scan-report-content::-webkit-scrollbar-thumb { background: rgba(0,255,136,0.3); border-radius: 2px; }
    
    .scan-section { margin-bottom: 12px; }
    .scan-section:last-child { margin-bottom: 0; }
    
    .scan-section-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 9px;
      color: #00FFFF;
      letter-spacing: 1px;
      margin-bottom: 6px;
      padding-bottom: 3px;
      border-bottom: 1px solid rgba(0,255,255,0.2);
    }
    
    .scan-data-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 4px;
    }
    
    .scan-data-item {
      background: rgba(0,255,136,0.05);
      border: 1px solid rgba(0,255,136,0.1);
      border-radius: 3px;
      padding: 6px;
    }
    
    .scan-data-label {
      font-size: 7px;
      color: rgba(255,255,255,0.5);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 2px;
    }
    
    .scan-data-value {
      font-family: 'Share Tech Mono', monospace;
      font-size: 11px;
      color: #00FF88;
      font-weight: 700;
    }
    
    .scan-data-value.warning { color: #FFD700; }
    .scan-data-value.danger { color: #FF4444; }
    .scan-data-value.info { color: #00FFFF; }
    
    .scan-findings { list-style: none; padding: 0; margin: 0; }
    
    .scan-finding {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 6px;
      background: rgba(0,0,0,0.2);
      border-radius: 3px;
      margin-bottom: 4px;
      border-left: 2px solid;
    }
    
    .scan-finding.anomaly { border-color: #FFD700; }
    .scan-finding.resource { border-color: #00FF88; }
    .scan-finding.hazard { border-color: #FF4444; }
    .scan-finding.life { border-color: #00FFFF; }
    
    .scan-finding-icon { font-size: 12px; flex-shrink: 0; }
    .scan-finding-text { flex: 1; min-width: 0; }
    .scan-finding-title { font-size: 10px; color: rgba(255,255,255,0.9); margin-bottom: 1px; font-weight: 600; }
    .scan-finding-desc { font-size: 8px; color: rgba(255,255,255,0.5); line-height: 1.2; }
    .scan-coordinates { font-family: 'Share Tech Mono', monospace; font-size: 7px; color: rgba(0,255,136,0.6); margin-top: 2px; }
    
    .scan-progress-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 2px;
      background: linear-gradient(90deg, #00FF88, #00FFFF);
      width: 0%;
      transition: width 0.1s linear;
    }
    
    /* Mobile: smaller report at top-right, doesn't cover much */
    @media (max-width: 768px) {
      :root { --bottom-panel-height: 115px; }
      
      .hud { font-size: 10px; padding: 8px; letter-spacing: 1px; }
      .hud-top-left { top: 10px; left: 10px; }
      .hud-top-right { display: none; }
      .hud-bottom-left { display: none; }
      .title { font-size: 11px; margin-bottom: 5px; }
      .data-row { margin: 2px 0; }
      
      .theme-btn { padding: 10px 14px; font-size: 10px; letter-spacing: 1px; min-height: 44px; }
      .theme-controls { gap: 8px; }
      .action-controls { gap: 8px; }
      .button-container { gap: 8px; }
      
      .scan-report {
        top: 10px;
        right: 10px;
        width: 200px;
        max-height: 45vh;
      }
      
      .scan-report-header { padding: 8px 10px; }
      .scan-report-title { font-size: 9px; letter-spacing: 1px; }
      .scan-report-content { padding: 8px; max-height: calc(45vh - 40px); }
      .scan-section { margin-bottom: 8px; }
      .scan-section-title { font-size: 8px; margin-bottom: 4px; }
      .scan-data-item { padding: 4px; }
      .scan-data-label { font-size: 6px; }
      .scan-data-value { font-size: 9px; }
      .scan-finding { padding: 4px; gap: 4px; }
      .scan-finding-icon { font-size: 10px; }
      .scan-finding-title { font-size: 9px; }
      .scan-finding-desc { font-size: 7px; }
    }
    
    @media (max-width: 480px) {
      :root { --bottom-panel-height: 105px; }
      
      .hud-top-left { top: 8px; left: 8px; padding: 6px; }
      .title { font-size: 9px; }
      .hud { font-size: 8px; }
      
      .theme-btn { padding: 8px 10px; font-size: 9px; min-height: 40px; }
      .theme-controls { gap: 6px; }
      .action-controls { gap: 6px; }
      
      .scan-report {
        width: 170px;
        max-height: 40vh;
      }
      
      .scan-report-content { max-height: calc(40vh - 35px); }
      .scan-data-grid { grid-template-columns: 1fr; }
    }
    
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: #0a0a0a;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.5s ease;
    }
    
    .loading-overlay.hidden { opacity: 0; pointer-events: none; }
    
    .loading-text {
      font-family: 'Orbitron', sans-serif;
      color: #00FFFF;
      font-size: 16px;
      letter-spacing: 4px;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="loading-overlay" id="loading">
    <div class="loading-text">INITIALIZING...</div>
  </div>
  
  <div id="canvas-container"></div>
  
  <div class="scan-report" id="scan-report">
    <div class="scan-report-header">
      <div class="scan-report-title">‚óà Scan Results</div>
    </div>
    <div class="scan-report-content" id="scan-report-content"></div>
    <div class="scan-progress-bar" id="scan-progress-bar"></div>
  </div>
  
  <div class="scanline"></div>
  
  <div class="hud hud-top-left">
    <div class="title">‚óà DESERT RECON // XS-4</div>
    <div class="data-row"><span class="label">ALT:</span> <span class="value" id="altitude">0000</span>m</div>
    <div class="data-row"><span class="label">SPD:</span> <span class="value" id="speed">000</span>km/h</div>
    <div class="data-row"><span class="label">HDG:</span> <span class="value" id="heading">000</span>¬∞</div>
  </div>
  
  <div class="hud hud-top-right">
    <div class="title">STATUS ‚óà</div>
    <div class="data-row"><span class="label">SYSTEM:</span> <span class="value">ONLINE</span></div>
    <div class="data-row"><span class="label">MODE:</span> <span class="value">RECON</span></div>
  </div>
  
  <div class="hud hud-bottom-left">
    <div class="data-row"><span class="label">LAT:</span> <span class="value" id="lat">47.3892</span>¬∞N</div>
    <div class="data-row"><span class="label">LON:</span> <span class="value" id="lon">-122.4821</span>¬∞W</div>
  </div>

  <div class="bottom-panel">
    <div class="button-container">
      <div class="theme-controls">
        <button class="theme-btn desert active" data-theme="desert">Desert</button>
        <button class="theme-btn jungle" data-theme="jungle">Jungle</button>
        <button class="theme-btn arctic" data-theme="arctic">Arctic</button>
      </div>
      <div class="action-controls">
        <button class="theme-btn barrel-roll" id="loop-btn">üõ© Roll</button>
        <button class="theme-btn barrel-roll" id="barrel-roll-btn">üîÉ Loop</button>
        <button class="theme-btn scan-btn" id="scan-btn">üì° Scan</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ========== UTILITIES ==========
    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func(...args), wait);
      };
    }
    
    function isMobileDevice() {
      const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      const isSmallScreen = window.innerWidth < 768 || window.innerHeight < 600;
      const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      return (hasTouch && isSmallScreen) || isMobileUA;
    }
    
    // ========== SIMPLEX NOISE ==========
    const SimplexNoise = (function() {
      const F2 = 0.5 * (Math.sqrt(3) - 1), G2 = (3 - Math.sqrt(3)) / 6;
      const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
      class SimplexNoise {
        constructor(seed = Math.random()) {
          this.p = new Uint8Array(256);
          this.perm = new Uint8Array(512);
          this.permMod12 = new Uint8Array(512);
          for (let i = 0; i < 256; i++) this.p[i] = i;
          let n, q;
          for (let i = 255; i > 0; i--) { 
            seed = (seed * 16807) % 2147483647; 
            n = seed % (i + 1); 
            q = this.p[i]; 
            this.p[i] = this.p[n]; 
            this.p[n] = q; 
          }
          for (let i = 0; i < 512; i++) { 
            this.perm[i] = this.p[i & 255]; 
            this.permMod12[i] = this.perm[i] % 12; 
          }
        }
        noise2D(x, y) {
          const s = (x + y) * F2, i = Math.floor(x + s), j = Math.floor(y + s), t = (i + j) * G2;
          const X0 = i - t, Y0 = j - t, x0 = x - X0, y0 = y - Y0;
          let i1, j1; 
          if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
          const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2, x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
          const ii = i & 255, jj = j & 255;
          let n0 = 0, n1 = 0, n2 = 0;
          let t0 = 0.5 - x0 * x0 - y0 * y0;
          if (t0 >= 0) { const gi0 = this.permMod12[ii + this.perm[jj]]; t0 *= t0; n0 = t0 * t0 * (grad3[gi0][0] * x0 + grad3[gi0][1] * y0); }
          let t1 = 0.5 - x1 * x1 - y1 * y1;
          if (t1 >= 0) { const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]]; t1 *= t1; n1 = t1 * t1 * (grad3[gi1][0] * x1 + grad3[gi1][1] * y1); }
          let t2 = 0.5 - x2 * x2 - y2 * y2;
          if (t2 >= 0) { const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]]; t2 *= t2; n2 = t2 * t2 * (grad3[gi2][0] * x2 + grad3[gi2][1] * y2); }
          return 70 * (n0 + n1 + n2);
        }
      }
      return SimplexNoise;
    })();

    // ========== INITIALIZATION ==========
    document.fonts.ready.then(() => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          initializeScene();
        });
      });
    });
    
    function initializeScene() {
      const container = document.getElementById('canvas-container');
      let isMobile = isMobileDevice();
      
      // ========== THREE.JS BEST PRACTICES: Configuration ==========
      const config = {
        // Limit pixel ratio - key mobile optimization
        pixelRatio: Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2),
        // Reduce geometry complexity on mobile
        terrainSize: isMobile ? 140 : 200,
        terrainSegments: isMobile ? 40 : 160,
        wallSegments: isMobile ? 24 : 100,
        // Static values
        terrainHeight: 25,
        volumeDepth: 50,
        // Frame rate
        targetFPS: isMobile ? 30 : 60
      };
      
      const scene = new THREE.Scene();
      // Disable fog on mobile - expensive
      if (!isMobile) {
        scene.fog = new THREE.FogExp2(0x00CED1, 0.001);
      }
      
      function getContainerDimensions() {
        const rect = container.getBoundingClientRect();
        return {
          width: Math.floor(rect.width) || window.innerWidth,
          height: Math.floor(rect.height) || (window.innerHeight - 115)
        };
      }
      
      const dims = getContainerDimensions();
      
      // ========== CAMERA - Optimized frustum ==========
      const camera = new THREE.PerspectiveCamera(
        isMobile ? 70 : 55,
        dims.width / dims.height,
        1,      // Near plane - as far as possible
        1500    // Far plane - as close as possible (was 4000)
      );
      camera.position.set(isMobile ? -150 : -200, isMobile ? 180 : 200, isMobile ? 150 : 200);
      camera.lookAt(0, 0, 0);

      // ========== RENDERER - Best practices ==========
      const renderer = new THREE.WebGLRenderer({ 
        antialias: !isMobile,           // Disable AA on mobile
        powerPreference: isMobile ? 'low-power' : 'high-performance',
        alpha: false,
        stencil: false,                 // Disable stencil buffer if not used
        depth: true,
        preserveDrawingBuffer: false,   // Better performance
        failIfMajorPerformanceCaveat: false
      });
      
      renderer.setSize(dims.width, dims.height);
      renderer.setPixelRatio(config.pixelRatio);
      renderer.setClearColor(0x00CED1);
      
      // Disable expensive features on mobile
      if (!isMobile) {
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
      }
      
      renderer.shadowMap.enabled = false;
      renderer.sortObjects = true;      // Enable for transparency
      container.appendChild(renderer.domElement);

      // WebGL context handling
      renderer.domElement.addEventListener('webglcontextlost', (e) => {
        e.preventDefault();
        cancelAnimationFrame(animationId);
      }, false);
      
      renderer.domElement.addEventListener('webglcontextrestored', () => {
        lastTime = performance.now();
        animate(lastTime);
      }, false);

      const simplex = new SimplexNoise(42);
      
      // ========== TERRAIN HEIGHT - Cached computation ==========
      // Pre-compute noise values for better performance
      function getTerrainHeight(x, z) {
        let height = 0;
        const scale = 0.018;
        height += simplex.noise2D(x * scale, z * scale) * 1.0;
        height += simplex.noise2D(x * scale * 2.5, z * scale * 2.5) * 0.5;
        // Skip extra octaves on mobile
        if (!isMobile) {
          height += simplex.noise2D(x * scale * 5, z * scale * 5) * 0.25;
        }
        height = Math.pow(Math.abs(height), 0.9) * Math.sign(height);
        let finalHeight = height * config.terrainHeight;
        const valleyFloor = -5.0, valleyThreshold = -2.0;
        if (finalHeight < valleyThreshold) {
          const transitionFactor = Math.min(1.0, (valleyThreshold - finalHeight) / (valleyThreshold - valleyFloor));
          finalHeight = finalHeight * (1.0 - transitionFactor) + valleyFloor * transitionFactor;
        }
        return finalHeight;
      }

      // ========== TERRAIN GEOMETRY ==========
      const terrainGeometry = new THREE.PlaneGeometry(
        config.terrainSize, 
        config.terrainSize, 
        config.terrainSegments, 
        config.terrainSegments
      );
      terrainGeometry.rotateX(-Math.PI / 2);
      
      const posAttr = terrainGeometry.attributes.position;
      const pos = posAttr.array;
      
      // Initial terrain setup
      for (let i = 0; i < pos.length; i += 3) {
        pos[i + 1] = getTerrainHeight(pos[i], pos[i + 2]);
      }
      posAttr.needsUpdate = true;
      terrainGeometry.computeVertexNormals();

      // ========== TERRAIN MATERIAL - Optimized shader ==========
      // Key optimization: Use simple MeshBasicMaterial variant for mobile
      const terrainMaterial = new THREE.ShaderMaterial({
        uniforms: {
          colorSand: { value: new THREE.Color(0xDEB8A0) },
          colorDune: { value: new THREE.Color(0xE8A87C) },
          colorPeak: { value: new THREE.Color(0x8B2942) },
          hasRivers: { value: 0.0 },
          riverColor: { value: new THREE.Color(0x00FFFF) }
        },
        vertexShader: `
          varying float vElevation;
          varying vec3 vNormal;
          void main() {
            vElevation = position.y;
            vNormal = normal;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 colorSand, colorDune, colorPeak, riverColor;
          uniform float hasRivers;
          varying float vElevation;
          varying vec3 vNormal;
          
          void main() {
            // Height-based coloring
            float h = clamp((vElevation + 20.0) / 40.0, 0.0, 1.0);
            vec3 color = h < 0.5 
              ? mix(colorSand, colorDune, h * 2.0) 
              : mix(colorDune, colorPeak, (h - 0.5) * 2.0);
            
            // River in valleys
            if (hasRivers > 0.5) {
              float riverMask = smoothstep(-3.5, -5.5, vElevation);
              color = mix(color, riverColor * 0.9, riverMask * 0.95);
            }
            
            // Simple lighting based on normal (baked look)
            vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
            float light = 0.5 + 0.5 * max(dot(vNormal, lightDir), 0.0);
            
            gl_FragColor = vec4(color * light, 1.0);
          }
        `,
        side: THREE.FrontSide
      });
      
      const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
      scene.add(terrain);

      // ========== VOLUME (Base and Walls) - With glowing edge ==========
      const volumeMaterial = new THREE.ShaderMaterial({
        uniforms: {
          baseColor: { value: new THREE.Color(0x2F8B7B) },
          edgeColor: { value: new THREE.Color(0x00FFFF) },
          volumeDepth: { value: config.volumeDepth }
        },
        vertexShader: `
          attribute float isTop;
          varying float vIsTop;
          varying vec3 vWorldNormal;
          void main() {
            vIsTop = isTop;
            vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 baseColor, edgeColor;
          varying float vIsTop;
          varying vec3 vWorldNormal;
          
          void main() {
            vec3 color = baseColor;
            
            // Simple lighting
            vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
            float light = 0.4 + 0.6 * max(dot(vWorldNormal, lightDir), 0.0);
            
            // Glowing edge at top
            float edgeGlow = smoothstep(0.85, 1.0, vIsTop);
            color = mix(color * light, edgeColor * 1.5, edgeGlow);
            
            gl_FragColor = vec4(color, 1.0);
          }
        `,
        side: THREE.DoubleSide
      });
      
      // Simple material for bottom plane (no edge needed)
      const bottomMaterial = new THREE.MeshBasicMaterial({
        color: 0x2F8B7B,
        side: THREE.DoubleSide
      });

      // Bottom plane
      const bottomGeometry = new THREE.PlaneGeometry(config.terrainSize, config.terrainSize);
      bottomGeometry.rotateX(-Math.PI / 2);
      const bottomPlane = new THREE.Mesh(bottomGeometry, bottomMaterial);
      bottomPlane.position.y = -config.volumeDepth;
      scene.add(bottomPlane);

      // Walls - with isTop attribute for edge glow
      function createWallStrip(samples) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(samples * 2 * 3);
        const normals = new Float32Array(samples * 2 * 3);
        const isTop = new Float32Array(samples * 2);
        const indices = [];
        
        // Mark top vertices
        for (let i = 0; i < samples; i++) {
          isTop[i * 2] = 1.0;      // Top vertex
          isTop[i * 2 + 1] = 0.0;  // Bottom vertex
        }
        
        for (let i = 0; i < samples - 1; i++) {
          const a = i * 2, b = i * 2 + 1, c = (i + 1) * 2, d = (i + 1) * 2 + 1;
          indices.push(a, b, c, b, d, c);
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
        geometry.setAttribute('isTop', new THREE.BufferAttribute(isTop, 1));
        geometry.setIndex(indices);
        return geometry;
      }
      
      const ws = config.wallSegments;
      const frontWallGeometry = createWallStrip(ws);
      const backWallGeometry = createWallStrip(ws);
      const leftWallGeometry = createWallStrip(ws);
      const rightWallGeometry = createWallStrip(ws);
      
      const frontWall = new THREE.Mesh(frontWallGeometry, volumeMaterial);
      const backWall = new THREE.Mesh(backWallGeometry, volumeMaterial);
      const leftWall = new THREE.Mesh(leftWallGeometry, volumeMaterial);
      const rightWall = new THREE.Mesh(rightWallGeometry, volumeMaterial);
      
      scene.add(frontWall, backWall, leftWall, rightWall);

      // ========== SHIP - Detailed spaceship ==========
      const heliGroup = new THREE.Group();
      heliGroup.position.set(0, 50, 0);
      scene.add(heliGroup);
      
      function createCoolSpaceship() {
        const shipGroup = new THREE.Group();
        
        // Main fuselage - sleek elongated shape
        const fuselageMat = new THREE.MeshStandardMaterial({ 
          color: 0x1a1a2e, 
          metalness: 0.9, 
          roughness: 0.2, 
          emissive: 0x0a0a15, 
          emissiveIntensity: 0.3 
        });
        
        // Main body - elongated diamond shape
        const bodyGeom = new THREE.ConeGeometry(2.5, 12, 4);
        bodyGeom.rotateZ(Math.PI / 2);
        bodyGeom.rotateY(Math.PI / 4);
        const body = new THREE.Mesh(bodyGeom, fuselageMat);
        body.scale.set(1, 0.4, 0.8);
        shipGroup.add(body);
        
        // Cockpit - glowing canopy
        const cockpitMat = new THREE.MeshStandardMaterial({ 
          color: 0x00ffff, 
          metalness: 0.1, 
          roughness: 0.1, 
          emissive: 0x00ffff, 
          emissiveIntensity: 0.8,
          transparent: true,
          opacity: 0.9
        });
        const cockpitGeom = new THREE.SphereGeometry(1.2, isMobile ? 8 : 16, isMobile ? 6 : 12);
        const cockpit = new THREE.Mesh(cockpitGeom, cockpitMat);
        cockpit.position.set(3, 0.5, 0);
        cockpit.scale.set(1.5, 0.6, 0.8);
        shipGroup.add(cockpit);
        
        // Wings - swept back aggressive style
        const wingMat = new THREE.MeshStandardMaterial({ 
          color: 0x2a1a4a, 
          metalness: 0.8, 
          roughness: 0.3 
        });
        
        const wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0);
        wingShape.lineTo(-6, 8);
        wingShape.lineTo(-8, 7);
        wingShape.lineTo(-2, 0);
        wingShape.lineTo(-8, -7);
        wingShape.lineTo(-6, -8);
        wingShape.closePath();
        
        const wingGeom = new THREE.ExtrudeGeometry(wingShape, { depth: 0.3, bevelEnabled: false });
        wingGeom.rotateX(Math.PI / 2);
        wingGeom.translate(0, 0, -0.15);
        const wings = new THREE.Mesh(wingGeom, wingMat);
        wings.position.set(-1, 0, 0);
        shipGroup.add(wings);
        
        // Vertical stabilizers
        const finGeom = new THREE.BoxGeometry(3, 0.2, 2.5);
        const finMat = new THREE.MeshStandardMaterial({ color: 0x3a2a5a, metalness: 0.7, roughness: 0.4 });
        
        const fin1 = new THREE.Mesh(finGeom, finMat);
        fin1.position.set(-4, 1.5, 2);
        fin1.rotation.x = 0.3;
        shipGroup.add(fin1);
        
        const fin2 = new THREE.Mesh(finGeom, finMat);
        fin2.position.set(-4, 1.5, -2);
        fin2.rotation.x = -0.3;
        shipGroup.add(fin2);
        
        // Engine pods
        const engineMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
        const engineGlowMat = new THREE.MeshBasicMaterial({ 
          color: 0x00ffff, 
          transparent: true, 
          opacity: 0.9 
        });
        
        const engineGeom = new THREE.CylinderGeometry(0.6, 0.9, 2, 8);
        engineGeom.rotateZ(Math.PI / 2);
        
        const engine1 = new THREE.Mesh(engineGeom, engineMat);
        engine1.position.set(-7, 0, 2.5);
        shipGroup.add(engine1);
        
        const engine2 = engine1.clone();
        engine2.position.set(-7, 0, -2.5);
        shipGroup.add(engine2);
        
        // Engine glow
        const glowGeom = new THREE.SphereGeometry(0.7, 8, 8);
        const glow1 = new THREE.Mesh(glowGeom, engineGlowMat);
        glow1.position.set(-8, 0, 2.5);
        glow1.scale.set(1.5, 1, 1);
        shipGroup.add(glow1);
        
        const glow2 = glow1.clone();
        glow2.position.set(-8, 0, -2.5);
        shipGroup.add(glow2);
        
        // Central engine
        const mainEngineGeom = new THREE.CylinderGeometry(1, 1.3, 3, 8);
        mainEngineGeom.rotateZ(Math.PI / 2);
        const mainEngine = new THREE.Mesh(mainEngineGeom, engineMat);
        mainEngine.position.set(-7.5, 0, 0);
        shipGroup.add(mainEngine);
        
        const mainGlow = new THREE.Mesh(glowGeom, engineGlowMat);
        mainGlow.position.set(-9, 0, 0);
        mainGlow.scale.set(2, 1.2, 1.2);
        shipGroup.add(mainGlow);
        
        // Nose cone detail
        const noseMat = new THREE.MeshStandardMaterial({ 
          color: 0x8B2942, 
          metalness: 0.9, 
          roughness: 0.1,
          emissive: 0x8B2942,
          emissiveIntensity: 0.3
        });
        const noseGeom = new THREE.ConeGeometry(0.8, 3, 8);
        noseGeom.rotateZ(-Math.PI / 2);
        const nose = new THREE.Mesh(noseGeom, noseMat);
        nose.position.set(7, 0, 0);
        shipGroup.add(nose);
        
        // Accent lights along wings (skip on mobile for performance)
        if (!isMobile) {
          const lightMat = new THREE.MeshBasicMaterial({ color: 0xff0044 });
          const lightGeom = new THREE.SphereGeometry(0.15, 6, 6);
          
          for (let i = 0; i < 4; i++) {
            const light1 = new THREE.Mesh(lightGeom, lightMat);
            light1.position.set(-2 - i * 1.5, 0.2, 3 + i * 1.2);
            shipGroup.add(light1);
            
            const light2 = new THREE.Mesh(lightGeom, lightMat);
            light2.position.set(-2 - i * 1.5, 0.2, -3 - i * 1.2);
            shipGroup.add(light2);
          }
        }
        
        shipGroup.scale.set(2, 2, 2);
        return shipGroup;
      }
      
      const ship = createCoolSpaceship();
      heliGroup.add(ship);

      // ========== SCAN BEAM - Simple cone ==========
      const scanBeamGeometry = new THREE.ConeGeometry(20, 50, isMobile ? 16 : 32, 1, true);
      const scanBeamMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FF88,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      const scanBeam = new THREE.Mesh(scanBeamGeometry, scanBeamMaterial);
      scanBeam.rotation.x = Math.PI;
      scanBeam.visible = false;
      scene.add(scanBeam);
      
      // Ground ring
      const ringGeometry = new THREE.RingGeometry(18, 25, isMobile ? 24 : 48);
      const ringMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FF88,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      const groundRing = new THREE.Mesh(ringGeometry, ringMaterial);
      groundRing.rotation.x = -Math.PI / 2;
      groundRing.visible = false;
      scene.add(groundRing);

      // ========== ANIMALS (Arctic only) ==========
      const animalGroup = new THREE.Group();
      const animalMat = new THREE.MeshBasicMaterial({ color: 0xF5F5F5 });
      const animalStep = isMobile ? 80 : 50;
      
      for (let x = -60; x <= 60; x += animalStep) {
        for (let z = -60; z <= 60; z += animalStep) {
          const animal = new THREE.Group();
          const px = x + (Math.random() - 0.5) * 30;
          const pz = z + (Math.random() - 0.5) * 30;
          
          // Simple box animal
          const bodyGeom = new THREE.BoxGeometry(3, 1.5, 2);
          const body = new THREE.Mesh(bodyGeom, animalMat);
          body.position.y = 0.75;
          animal.add(body);
          
          animal.userData = { initialX: px, initialZ: pz };
          animal.position.set(px, getTerrainHeight(px, pz), pz);
          animal.rotation.y = Math.random() * Math.PI * 2;
          animalGroup.add(animal);
        }
      }
      animalGroup.visible = false;
      scene.add(animalGroup);

      // ========== LIGHTING - Minimal ==========
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);
      
      // Only add directional light on desktop
      if (!isMobile) {
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);
      }

      // ========== ANIMATION STATE ==========
      let time = 0;
      let scrollOffset = 0;
      const scrollSpeed = isMobile ? 24 : 32;
      
      let barrelRollActive = false, barrelRollProgress = 0;
      let loopActive = false, loopProgress = 0;
      
      let scanActive = false, scanProgress = 0, scanTime = 0;
      const scanDuration = 2.5;
      
      let animationId;
      let lastTime = performance.now();
      const frameInterval = 1000 / config.targetFPS;
      let frameAccumulator = 0;
      
      // Reusable vectors (avoid allocation in loop)
      const shipWorldPos = new THREE.Vector3();

      // ========== WALL UPDATE ==========
      function updateWalls() {
        const halfSize = config.terrainSize / 2;
        const walls = [
          [frontWallGeometry, halfSize, true],
          [backWallGeometry, -halfSize, true],
          [leftWallGeometry, -halfSize, false],
          [rightWallGeometry, halfSize, false]
        ];
        
        walls.forEach(([geom, coord, isZ]) => {
          const arr = geom.attributes.position.array;
          for (let i = 0; i < ws; i++) {
            const t = i / (ws - 1);
            const primary = -halfSize + t * config.terrainSize;
            const x = isZ ? primary : coord;
            const z = isZ ? coord : primary;
            const height = getTerrainHeight(x + scrollOffset, z);
            const idx = i * 6;
            arr[idx] = x;
            arr[idx + 1] = height;
            arr[idx + 2] = z;
            arr[idx + 3] = x;
            arr[idx + 4] = -config.volumeDepth;
            arr[idx + 5] = z;
          }
          geom.attributes.position.needsUpdate = true;
          geom.computeVertexNormals();
        });
      }

      // ========== MAIN ANIMATION LOOP ==========
      function animate(currentTime) {
        animationId = requestAnimationFrame(animate);
        
        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;
        
        // Frame rate limiting
        if (isMobile) {
          frameAccumulator += deltaTime;
          if (frameAccumulator < frameInterval) return;
          frameAccumulator -= frameInterval;
        }
        
        const dt = Math.min(deltaTime / 1000, 0.1);
        time += dt;
        scrollOffset += scrollSpeed * dt;

        // Update terrain vertices
        for (let i = 0; i < pos.length; i += 3) {
          pos[i + 1] = getTerrainHeight(pos[i] + scrollOffset, pos[i + 2]);
        }
        posAttr.needsUpdate = true;
        
        // Compute normals every frame for proper lighting (fixes shadow issue)
        terrainGeometry.computeVertexNormals();

        // Update walls
        updateWalls();

        // Update animals if visible
        if (animalGroup.visible) {
          const halfSize = config.terrainSize / 2;
          animalGroup.children.forEach(a => {
            let newX = a.userData.initialX - (scrollOffset % (config.terrainSize * 2));
            while (newX < -halfSize) newX += config.terrainSize;
            while (newX > halfSize) newX -= config.terrainSize;
            a.position.x = newX;
            a.position.y = getTerrainHeight(a.userData.initialX, a.userData.initialZ);
          });
        }

        // Ship movement
        let baseX = Math.sin(time * 0.8) * 25 + Math.sin(time * 1.6) * 10;
        let baseZ = Math.sin(time * 0.7) * 18 + Math.cos(time * 1.2) * 8;
        let baseY = 45 + Math.sin(time * 0.9) * 8;
        
        let rollAngle = Math.sin(time * 0.4) * 0.05;
        let pitchAngle = Math.sin(time * 0.7) * 0.1;
        let yawAngle = Math.sin(time * 0.5) * 0.15;
        
        // Barrel roll
        if (barrelRollActive) {
          barrelRollProgress += dt / 1.2;
          if (barrelRollProgress >= 1.0) {
            barrelRollProgress = 0;
            barrelRollActive = false;
          } else {
            const angle = barrelRollProgress * Math.PI * 2;
            baseY += Math.sin(angle) * 15;
            rollAngle = angle;
          }
        }
        
        // Loop
        if (loopActive) {
          loopProgress += dt / 1.5;
          if (loopProgress >= 1.0) {
            loopProgress = 0;
            loopActive = false;
          } else {
            const angle = loopProgress * Math.PI * 2;
            baseY += Math.sin(angle) * 25;
            baseX += (Math.cos(angle) - 1) * 20;
            pitchAngle = angle;
          }
        }
        
        heliGroup.position.set(baseX, baseY, baseZ);
        heliGroup.rotation.set(pitchAngle, yawAngle, rollAngle);
        
        // Scan beam animation
        if (scanActive) {
          scanTime += dt;
          scanProgress = Math.min(scanTime / scanDuration, 1.0);
          
          heliGroup.getWorldPosition(shipWorldPos);
          const terrainY = getTerrainHeight(shipWorldPos.x + scrollOffset, shipWorldPos.z);
          
          // Position beam
          scanBeam.position.set(shipWorldPos.x, shipWorldPos.y - 25, shipWorldPos.z);
          const beamHeight = Math.max(10, shipWorldPos.y - terrainY - 5);
          scanBeam.scale.y = beamHeight / 50;
          
          // Animate opacity
          const opacity = Math.sin(scanProgress * Math.PI) * 0.4;
          scanBeamMaterial.opacity = opacity;
          ringMaterial.opacity = opacity * 1.5;
          
          // Position ground ring
          groundRing.position.set(shipWorldPos.x, terrainY + 0.5, shipWorldPos.z);
          
          // Pulse effect
          const pulse = 1 + Math.sin(scanTime * 8) * 0.1;
          groundRing.scale.set(pulse, pulse, 1);
          
          if (scanProgress >= 1.0) {
            scanActive = false;
            scanBeam.visible = false;
            groundRing.visible = false;
            finishScan();
          }
        }
        
        // Update report progress
        if (reportDisplayTime >= 0 && !scanActive) {
          reportDisplayTime += dt;
          const progress = Math.min(reportDisplayTime / reportDisplayDuration, 1);
          scanProgressBar.style.width = (progress * 100) + '%';
          
          if (reportDisplayTime >= reportDisplayDuration) {
            hideScanReport();
            reportDisplayTime = -1;
          }
        }

        // Update HUD
        document.getElementById('altitude').textContent = Math.floor(heliGroup.position.y * 10 + 500).toString().padStart(4, '0');
        document.getElementById('speed').textContent = Math.floor(150 + Math.sin(time) * 20).toString().padStart(3, '0');
        document.getElementById('heading').textContent = Math.floor((Math.atan2(Math.sin(time * 0.3), Math.cos(time * 0.3)) * 180 / Math.PI + 360) % 360).toString().padStart(3, '0');

        renderer.render(scene, camera);
      }

      // ========== RESIZE HANDLING ==========
      function updateRendererSize() {
        const dims = getContainerDimensions();
        camera.aspect = dims.width / dims.height;
        camera.updateProjectionMatrix();
        renderer.setSize(dims.width, dims.height);
      }
      
      const debouncedResize = debounce(() => {
        isMobile = isMobileDevice();
        updateRendererSize();
      }, 150);
      
      window.addEventListener('resize', debouncedResize);
      window.addEventListener('orientationchange', () => setTimeout(updateRendererSize, 300));

      // ========== VISIBILITY HANDLING ==========
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          cancelAnimationFrame(animationId);
        } else {
          lastTime = performance.now();
          animate(lastTime);
        }
      });

      // ========== SCAN FUNCTIONALITY ==========
      const scanBtn = document.getElementById('scan-btn');
      const scanReport = document.getElementById('scan-report');
      const scanReportContent = document.getElementById('scan-report-content');
      const scanProgressBar = document.getElementById('scan-progress-bar');
      
      let currentTheme = 'desert';
      let reportDisplayTime = -1;
      const reportDisplayDuration = 4.0;
      
      const themeScanData = {
        desert: {
          biome: 'Arid Desert', climate: 'Hot & Dry', avgTemp: '42¬∞C', humidity: '12%',
          resources: [
            { type: 'resource', icon: 'üî∂', title: 'Copper Deposits', desc: 'High-grade ore in mesa formations' },
            { type: 'anomaly', icon: '‚ö°', title: 'EM Anomaly', desc: 'Unknown readings beneath dunes' }
          ],
          hazards: [{ type: 'hazard', icon: 'üå°Ô∏è', title: 'Thermal Extremes', desc: 'Surface temps exceed safe limits' }],
          lifeforms: []
        },
        jungle: {
          biome: 'Rainforest', climate: 'Hot & Humid', avgTemp: '31¬∞C', humidity: '89%',
          resources: [
            { type: 'resource', icon: 'üåø', title: 'Medicinal Flora', desc: 'Bioactive compounds detected' },
            { type: 'resource', icon: 'üíß', title: 'Fresh Water', desc: 'Aquifer at 12m depth' }
          ],
          hazards: [{ type: 'hazard', icon: '‚ò†Ô∏è', title: 'Toxic Spores', desc: 'Filtration recommended' }],
          lifeforms: [{ type: 'life', icon: 'ü¶ú', title: 'Avian Species', desc: '127 bird species detected' }]
        },
        arctic: {
          biome: 'Polar Tundra', climate: 'Freezing', avgTemp: '-18¬∞C', humidity: '45%',
          resources: [
            { type: 'resource', icon: '‚ùÑÔ∏è', title: 'Ice Deposits', desc: 'Ancient glacial ice' },
            { type: 'anomaly', icon: 'üîÆ', title: 'Subglacial Structure', desc: 'Geometric formation at 200m' }
          ],
          hazards: [{ type: 'hazard', icon: 'ü•∂', title: 'Hypothermia Risk', desc: 'Thermal protection required' }],
          lifeforms: [
            { type: 'life', icon: 'üêª‚Äç‚ùÑÔ∏è', title: 'Polar Bears', desc: '12 individuals detected' },
            { type: 'life', icon: 'üêß', title: 'Penguin Colony', desc: '~2,400 individuals' }
          ]
        }
      };
      
      function generateScanReport() {
        const data = themeScanData[currentTheme];
        const scanId = Math.random().toString(36).substring(2, 6).toUpperCase();
        
        let minH = Infinity, maxH = -Infinity;
        for (let i = 1; i < pos.length; i += 3) {
          minH = Math.min(minH, pos[i]);
          maxH = Math.max(maxH, pos[i]);
        }
        
        return `
          <div class="scan-section">
            <div class="scan-section-title">‚óà Environment</div>
            <div class="scan-data-grid">
              <div class="scan-data-item"><div class="scan-data-label">Biome</div><div class="scan-data-value">${data.biome}</div></div>
              <div class="scan-data-item"><div class="scan-data-label">Temp</div><div class="scan-data-value ${parseFloat(data.avgTemp) > 35 ? 'warning' : parseFloat(data.avgTemp) < 0 ? 'info' : ''}">${data.avgTemp}</div></div>
              <div class="scan-data-item"><div class="scan-data-label">Elev Range</div><div class="scan-data-value">${(maxH - minH).toFixed(0)}m</div></div>
              <div class="scan-data-item"><div class="scan-data-label">Scan ID</div><div class="scan-data-value info">#${scanId}</div></div>
            </div>
          </div>
          ${data.hazards.length ? `
          <div class="scan-section">
            <div class="scan-section-title">‚ö† Hazards</div>
            <ul class="scan-findings">${data.hazards.map(h => `
              <li class="scan-finding ${h.type}"><span class="scan-finding-icon">${h.icon}</span><div class="scan-finding-text"><div class="scan-finding-title">${h.title}</div><div class="scan-finding-desc">${h.desc}</div></div></li>
            `).join('')}</ul>
          </div>` : ''}
          <div class="scan-section">
            <div class="scan-section-title">‚óà Discoveries</div>
            <ul class="scan-findings">${data.resources.map(r => `
              <li class="scan-finding ${r.type}"><span class="scan-finding-icon">${r.icon}</span><div class="scan-finding-text"><div class="scan-finding-title">${r.title}</div><div class="scan-finding-desc">${r.desc}</div></div></li>
            `).join('')}</ul>
          </div>
          ${data.lifeforms.length ? `
          <div class="scan-section">
            <div class="scan-section-title">‚óà Lifeforms</div>
            <ul class="scan-findings">${data.lifeforms.map(l => `
              <li class="scan-finding ${l.type}"><span class="scan-finding-icon">${l.icon}</span><div class="scan-finding-text"><div class="scan-finding-title">${l.title}</div><div class="scan-finding-desc">${l.desc}</div></div></li>
            `).join('')}</ul>
          </div>` : ''}
        `;
      }
      
      function showScanReport() {
        scanReportContent.innerHTML = generateScanReport();
        scanReport.classList.remove('fading-out');
        scanReport.classList.add('visible');
        scanProgressBar.style.width = '0%';
      }
      
      function hideScanReport() {
        scanReport.classList.add('fading-out');
        scanReport.classList.remove('visible');
        scanBtn.classList.remove('scanning');
        scanBtn.textContent = 'üì° Scan';
      }
      
      function finishScan() {
        reportDisplayTime = 0;
      }
      
      function startScan() {
        if (scanActive) return;
        
        scanActive = true;
        scanProgress = 0;
        scanTime = 0;
        reportDisplayTime = -1;
        
        scanBtn.classList.add('scanning');
        scanBtn.textContent = '‚è≥ Scanning...';
        
        // Update beam color for theme
        const colors = { desert: 0x00FF88, jungle: 0x39FF14, arctic: 0x7FFFD4 };
        scanBeamMaterial.color.setHex(colors[currentTheme]);
        ringMaterial.color.setHex(colors[currentTheme]);
        
        scanBeam.visible = true;
        groundRing.visible = true;
        
        showScanReport();
      }
      
      scanBtn.addEventListener('click', startScan);

      // ========== THEME SYSTEM ==========
      const themes = {
        desert: {
          background: 0x00CED1, title: 'DESERT RECON // XS-4',
          colorSand: new THREE.Color(0xDEB8A0),
          colorDune: new THREE.Color(0xE8A87C),
          colorPeak: new THREE.Color(0x8B2942),
          hasRivers: false, riverColor: new THREE.Color(0x00FFFF),
          volumeColor: new THREE.Color(0x2F8B7B),
          edgeColor: new THREE.Color(0x00FFFF),
          hudTitle: '#8B2942', hudLabel: '#DEB8A0', hudValue: '#00FFFF',
          showAnimals: false
        },
        jungle: {
          background: 0xA8BF6A, title: 'JUNGLE RECON // XS-4',
          colorSand: new THREE.Color(0xD4A857),
          colorDune: new THREE.Color(0xC46A41),
          colorPeak: new THREE.Color(0x1B4D3E),
          hasRivers: true, riverColor: new THREE.Color(0x0277BD),
          volumeColor: new THREE.Color(0x7A6840),
          edgeColor: new THREE.Color(0x39FF14),
          hudTitle: '#1B4D3E', hudLabel: '#C46A41', hudValue: '#39FF14',
          showAnimals: false
        },
        arctic: {
          background: 0xB0E0E6, title: 'ARCTIC RECON // XS-4',
          colorSand: new THREE.Color(0xD6E5F0),
          colorDune: new THREE.Color(0xF0F8FF),
          colorPeak: new THREE.Color(0x4A6B8A),
          hasRivers: true, riverColor: new THREE.Color(0xA8C8DC),
          volumeColor: new THREE.Color(0x5D6D7E),
          edgeColor: new THREE.Color(0x7FFFD4),
          hudTitle: '#2C3E50', hudLabel: '#A8C8DC', hudValue: '#7FFFD4',
          showAnimals: true
        }
      };

      function applyTheme(themeName) {
        currentTheme = themeName;
        const t = themes[themeName];
        
        renderer.setClearColor(t.background);
        
        terrainMaterial.uniforms.colorSand.value = t.colorSand;
        terrainMaterial.uniforms.colorDune.value = t.colorDune;
        terrainMaterial.uniforms.colorPeak.value = t.colorPeak;
        terrainMaterial.uniforms.hasRivers.value = t.hasRivers ? 1.0 : 0.0;
        terrainMaterial.uniforms.riverColor.value = t.riverColor;
        
        // Update volume and edge colors
        volumeMaterial.uniforms.baseColor.value = t.volumeColor;
        volumeMaterial.uniforms.edgeColor.value = t.edgeColor;
        bottomMaterial.color = t.volumeColor;
        
        animalGroup.visible = t.showAnimals;
        
        document.querySelector('.hud-top-left .title').textContent = `‚óà ${t.title}`;
        document.querySelectorAll('.title').forEach(el => el.style.color = t.hudTitle);
        document.querySelectorAll('.label').forEach(el => el.style.color = t.hudLabel);
        document.querySelectorAll('.value').forEach(el => el.style.color = t.hudValue);
        
        document.querySelectorAll('.theme-btn[data-theme]').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.theme === themeName);
        });
      }

      document.querySelectorAll('.theme-btn[data-theme]').forEach(btn => {
        btn.addEventListener('click', () => applyTheme(btn.dataset.theme));
      });

      document.getElementById('barrel-roll-btn').addEventListener('click', () => {
        if (!barrelRollActive) { barrelRollActive = true; barrelRollProgress = 0; }
      });

      document.getElementById('loop-btn').addEventListener('click', () => {
        if (!loopActive) { loopActive = true; loopProgress = 0; }
      });

      // ========== START ==========
      updateWalls();
      updateRendererSize();
      document.getElementById('loading').classList.add('hidden');
      lastTime = performance.now();
      animate(lastTime);
    }
  </script>
</body>
</html>