<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>XS-4 Terrain Scanner</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0a; overflow: hidden; font-family: 'Share Tech Mono', monospace; touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
    #canvas-container { position: fixed; top: 0; left: 0; right: 0; bottom: 80px; }
    canvas { display: block; width: 100%; height: 100%; }
    .bottom-panel { position: fixed; bottom: 0; left: 0; right: 0; height: 80px; background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%); border-top: 2px solid #333; display: flex; align-items: center; justify-content: center; gap: 20px; z-index: 102; }
    .hud { position: fixed; color: #8B2942; font-size: 13px; text-transform: uppercase; letter-spacing: 2px; pointer-events: none; text-shadow: 0 0 8px rgba(0,0,0,0.8); background: rgba(0,0,0,0.25); backdrop-filter: blur(8px); padding: 15px; border-radius: 8px; z-index: 101; }
    .hud-top-left { top: 20px; left: 20px; }
    .hud-top-right { top: 20px; right: 20px; text-align: right; }
    .hud-bottom-left { bottom: 100px; left: 20px; }
    .title { font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700; margin-bottom: 10px; color: #8B2942; }
    .data-row { margin: 5px 0; }
    .label { color: #E8A87C; font-weight: 600; }
    .value { color: #00FFFF; font-weight: 700; }
    .scanline { position: fixed; inset: 0; pointer-events: none; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.005) 2px, rgba(0,0,0,0.005) 4px); z-index: 100; }
    .vignette { position: fixed; inset: 0; pointer-events: none; background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.08) 100%); z-index: 99; }
    .theme-controls { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; align-items: center; padding: 0 10px; }
    .theme-btn { padding: 14px 24px; font-family: 'Share Tech Mono', monospace; font-size: 13px; text-transform: uppercase; letter-spacing: 2px; border: 2px solid; background: rgba(0,0,0,0.5); cursor: pointer; transition: all 0.3s ease; font-weight: 700; border-radius: 4px; white-space: nowrap; }
    .theme-btn.desert { border-color: #E8A87C; color: #E8A87C; }
    .theme-btn.jungle { border-color: #39FF14; color: #39FF14; }
    .theme-btn.arctic { border-color: #7FFFD4; color: #7FFFD4; }
    .theme-btn.barrel-roll { border-color: #FF6600; color: #FF6600; }
    .theme-btn.barrel-roll:hover { background: rgba(255, 102, 0, 0.2); }
    .theme-btn.active { transform: scale(1.05); background: rgba(255,255,255,0.2); box-shadow: 0 0 20px currentColor; }
    .theme-btn:hover { background: rgba(255,255,255,0.15); box-shadow: 0 0 15px currentColor; }
    
    /* Tablet */
    @media (max-width: 900px) {
      .theme-btn { padding: 12px 18px; font-size: 12px; letter-spacing: 1px; }
      .theme-controls { gap: 10px; }
    }
    
    /* Mobile */
    @media (max-width: 768px) {
      .hud { font-size: 10px; padding: 10px; letter-spacing: 1px; }
      .hud-top-left { top: 10px; left: 10px; }
      .hud-top-right { top: 10px; right: 10px; }
      .hud-bottom-left { bottom: 95px; left: 10px; }
      .title { font-size: 12px; margin-bottom: 6px; }
      .data-row { margin: 3px 0; }
      #canvas-container { bottom: 85px; }
      .bottom-panel { height: 85px; padding: 10px; }
      .theme-controls { gap: 8px; }
      .theme-btn { padding: 10px 14px; font-size: 10px; letter-spacing: 1px; min-height: 44px; min-width: 44px; }
    }
    
    /* Small mobile */
    @media (max-width: 480px) {
      .hud-top-right { display: none; }
      .hud-bottom-left { display: none; }
      .hud-top-left { top: 8px; left: 8px; padding: 8px; }
      .title { font-size: 10px; }
      .hud { font-size: 9px; }
      #canvas-container { bottom: 75px; }
      .bottom-panel { height: 75px; padding: 8px; }
      .theme-btn { padding: 8px 10px; font-size: 9px; min-height: 40px; }
      .theme-controls { gap: 6px; }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div class="scanline"></div>
  <div class="vignette"></div>
  <div class="hud hud-top-left">
    <div class="title">â—ˆ DESERT RECON // XS-4</div>
    <div class="data-row"><span class="label">ALT:</span> <span class="value" id="altitude">0000</span>m</div>
    <div class="data-row"><span class="label">SPD:</span> <span class="value" id="speed">000</span>km/h</div>
    <div class="data-row"><span class="label">HDG:</span> <span class="value" id="heading">000</span>Â°</div>
  </div>
  <div class="hud hud-top-right">
    <div class="title">STATUS â—ˆ</div>
    <div class="data-row"><span class="label">SYSTEM:</span> <span class="value">ONLINE</span></div>
    <div class="data-row"><span class="label">MODE:</span> <span class="value">RECON</span></div>
  </div>
  <div class="hud hud-bottom-left">
    <div class="data-row"><span class="label">LAT:</span> <span class="value" id="lat">47.3892</span>Â°N</div>
    <div class="data-row"><span class="label">LON:</span> <span class="value" id="lon">-122.4821</span>Â°W</div>
  </div>

  <div class="bottom-panel">
    <div class="theme-controls">
      <button class="theme-btn desert active" data-theme="desert">Desert</button>
      <button class="theme-btn jungle" data-theme="jungle">Jungle</button>
      <button class="theme-btn arctic" data-theme="arctic">Arctic</button>
      <button class="theme-btn barrel-roll" id="barrel-roll-btn">ðŸ›© Roll</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    // Simplex Noise
    const SimplexNoise = (function () {
      const F2 = 0.5 * (Math.sqrt(3) - 1), G2 = (3 - Math.sqrt(3)) / 6;
      const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
      class SimplexNoise {
        constructor(seed = Math.random()) {
          this.p = new Uint8Array(256); this.perm = new Uint8Array(512); this.permMod12 = new Uint8Array(512);
          for (let i = 0; i < 256; i++) this.p[i] = i;
          let n, q;
          for (let i = 255; i > 0; i--) { seed = (seed * 16807) % 2147483647; n = seed % (i + 1); q = this.p[i]; this.p[i] = this.p[n]; this.p[n] = q; }
          for (let i = 0; i < 512; i++) { this.perm[i] = this.p[i & 255]; this.permMod12[i] = this.perm[i] % 12; }
        }
        noise2D(x, y) {
          const s = (x + y) * F2, i = Math.floor(x + s), j = Math.floor(y + s), t = (i + j) * G2;
          const X0 = i - t, Y0 = j - t, x0 = x - X0, y0 = y - Y0;
          let i1, j1; if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
          const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2, x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
          const ii = i & 255, jj = j & 255;
          let n0 = 0, n1 = 0, n2 = 0;
          let t0 = 0.5 - x0 * x0 - y0 * y0;
          if (t0 >= 0) { const gi0 = this.permMod12[ii + this.perm[jj]]; t0 *= t0; n0 = t0 * t0 * (grad3[gi0][0] * x0 + grad3[gi0][1] * y0); }
          let t1 = 0.5 - x1 * x1 - y1 * y1;
          if (t1 >= 0) { const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]]; t1 *= t1; n1 = t1 * t1 * (grad3[gi1][0] * x1 + grad3[gi1][1] * y1); }
          let t2 = 0.5 - x2 * x2 - y2 * y2;
          if (t2 >= 0) { const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]]; t2 *= t2; n2 = t2 * t2 * (grad3[gi2][0] * x2 + grad3[gi2][1] * y2); }
          return 70 * (n0 + n1 + n2);
        }
      }
      return SimplexNoise;
    })();

    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x00CED1, 0);
    
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
    
    const camera = new THREE.PerspectiveCamera(isMobile ? 65 : 55, window.innerWidth / window.innerHeight, 0.1, 4000);
    camera.position.set(isMobile ? -180 : -200, isMobile ? 220 : 200, isMobile ? 180 : 200);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: isMobile ? 'low-power' : 'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, isMobile ? 1 : 2));
    renderer.setClearColor(0x00CED1);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.shadowMap.enabled = false;
    container.appendChild(renderer.domElement);

    const simplex = new SimplexNoise(42);
    const terrainSize = isMobile ? 160 : 200;
    const terrainSegments = isMobile ? 48 : 192;
    const terrainHeight = 25;
    const volumeDepth = 50;

    function getTerrainHeight(x, z) {
      let height = 0; const scale = 0.018;
      height += simplex.noise2D(x * scale, z * scale) * 1.0;
      height += simplex.noise2D(x * scale * 2.5, z * scale * 2.5) * 0.5;
      height += simplex.noise2D(x * scale * 5, z * scale * 5) * 0.25;
      height += simplex.noise2D(x * scale * 10, z * scale * 10) * 0.125;
      height = Math.pow(Math.abs(height), 0.9) * Math.sign(height);
      let finalHeight = height * terrainHeight;
      const valleyFloor = -5.0, valleyThreshold = -2.0;
      if (finalHeight < valleyThreshold) {
        const transitionFactor = (valleyThreshold - finalHeight) / (valleyThreshold - valleyFloor);
        finalHeight = finalHeight * (1.0 - Math.min(1.0, transitionFactor)) + valleyFloor * Math.min(1.0, transitionFactor);
      }
      return finalHeight;
    }

    const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
    terrainGeometry.rotateX(-Math.PI / 2);
    const posAttr = terrainGeometry.attributes.position, pos = posAttr.array;
    for (let i = 0; i < pos.length; i += 3) pos[i + 1] = getTerrainHeight(pos[i], pos[i + 2]);
    posAttr.needsUpdate = true;
    terrainGeometry.computeVertexNormals();

    const terrainMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 }, scrollOffset: { value: 0 },
        colorSand: { value: new THREE.Color(0xDEB8A0) },
        colorDune: { value: new THREE.Color(0xE8A87C) },
        colorPeak: { value: new THREE.Color(0x8B2942) },
        hasRivers: { value: 0.0 },
        riverColor: { value: new THREE.Color(0x00FFFF) }
      },
      vertexShader: `varying vec3 vPosition; varying vec3 vNormal; varying float vElevation;
        void main() { vPosition = position; vNormal = normal; vElevation = position.y; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
      fragmentShader: `
        uniform float time, scrollOffset, hasRivers;
        uniform vec3 colorSand, colorDune, colorPeak, riverColor;
        varying vec3 vPosition, vNormal; varying float vElevation;
        float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
        void main() {
          float heightFactor = clamp((vElevation + 20.0) / 40.0, 0.0, 1.0);
          vec3 color = heightFactor < 0.5 ? mix(colorSand, colorDune, heightFactor * 2.0) : mix(colorDune, colorPeak, (heightFactor - 0.5) * 2.0);
          if (hasRivers > 0.5) {
            vec2 scrolledPos = vec2(vPosition.x + scrollOffset, vPosition.z);
            float notOnValleyFloor = smoothstep(-6.0, -3.0, vElevation);
            vec2 cellCoord = floor(scrolledPos / 16.0);
            float neighbors = 0.0;
            for (float dx = -1.0; dx <= 1.0; dx += 1.0) for (float dz = -1.0; dz <= 1.0; dz += 1.0) if (dx != 0.0 || dz != 0.0) if (hash(cellCoord + vec2(dx, dz)) > 0.2) neighbors += 1.0;
            float lifePattern = (neighbors >= 2.0 && neighbors <= 7.0) ? 1.0 : (neighbors >= 1.0 && hash(cellCoord) > 0.25) ? 0.9 : 0.0;
            float forestCoverage = smoothstep(0.2, 0.8, lifePattern * notOnValleyFloor);
            float elevationDarkness = pow(smoothstep(-10.0, 10.0, vElevation), 0.7);
            vec3 forestColor = neighbors >= 5.0 ? colorSand * (0.12 + elevationDarkness * 0.08) : neighbors >= 3.0 ? colorSand * (0.20 + elevationDarkness * 0.12) : colorSand * (0.30 + elevationDarkness * 0.15);
            color = mix(color, forestColor, forestCoverage * 0.95);
            float isValleyFloor = smoothstep(-3.5, -5.5, vElevation);
            color = mix(color, riverColor * (0.85 + sin(time * 0.5) * 0.1), isValleyFloor * 0.98);
          }
          vec3 lightDir = normalize(vec3(0.6, 0.8, 0.7));
          float diffuse = max(dot(vNormal, lightDir), 0.0);
          float frontFacing = max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));
          float sideFacing = abs(dot(vNormal, vec3(1.0, 0.0, 0.0)));
          float ambient = 0.35;
          float shadowFactor = 1.0 - sideFacing * 0.5;
          float lit = ambient + diffuse * 0.65 * shadowFactor;
          gl_FragColor = vec4(color * lit, 1.0);
        }`,
      side: THREE.DoubleSide
    });
    const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
    scene.add(terrain);

    const volumeMaterial = new THREE.ShaderMaterial({
      uniforms: { 
        baseColor: { value: new THREE.Color(0x2F8B7B) }, 
        gridColor: { value: new THREE.Color(0x00FFFF) },
        isMobile: { value: isMobile ? 1.0 : 0.0 }
      },
      vertexShader: `varying vec3 vPosition, vNormal, vWorldNormal; 
        void main() { 
          vPosition = position; 
          vNormal = normal; 
          vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
        }`,
      fragmentShader: `uniform vec3 baseColor, gridColor;
        uniform float isMobile;
        varying vec3 vPosition, vNormal, vWorldNormal;
        void main() {
          vec3 color = baseColor;
          
          // Only show grid on desktop
          if (isMobile < 0.5) {
            float gridSize = 4.0; 
            vec2 grid = abs(fract(vPosition.xy / gridSize - 0.5) - 0.5) / fwidth(vPosition.xy / gridSize);
            float gridMask = 1.0 - min(min(grid.x, grid.y), 1.0);
            color = mix(baseColor, gridColor, gridMask * 0.15);
          }
          
          vec3 lightDir = normalize(vec3(0.6, 0.8, 0.7));
          float diffuse = max(dot(vWorldNormal, lightDir), 0.0);
          float frontFacing = max(0.0, vWorldNormal.z);
          float sideFacing = abs(vWorldNormal.x);
          float ambient = 0.25;
          float shadowAmount = sideFacing * 0.6;
          float lit = ambient + diffuse * 0.75 * (1.0 - shadowAmount);
          lit = mix(lit, lit * 0.5, step(0.9, sideFacing));
          gl_FragColor = vec4(color * lit, 1.0);
        }`,
      side: THREE.DoubleSide
    });

    const bottomGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize);
    bottomGeometry.rotateX(-Math.PI / 2);
    const bottomPlane = new THREE.Mesh(bottomGeometry, volumeMaterial);
    bottomPlane.position.y = -volumeDepth;
    scene.add(bottomPlane);

    const wallSegments = isMobile ? 32 : 128;
    function createWallStrip(samples) {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(samples * 2 * 3), normals = new Float32Array(samples * 2 * 3), indices = [];
      for (let i = 0; i < samples - 1; i++) { const a = i * 2, b = i * 2 + 1, c = (i + 1) * 2, d = (i + 1) * 2 + 1; indices.push(a, b, c, b, d, c); }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
      geometry.setIndex(indices);
      return geometry;
    }
    const frontWallGeometry = createWallStrip(wallSegments), frontWall = new THREE.Mesh(frontWallGeometry, volumeMaterial); scene.add(frontWall);
    const backWallGeometry = createWallStrip(wallSegments), backWall = new THREE.Mesh(backWallGeometry, volumeMaterial); scene.add(backWall);
    const leftWallGeometry = createWallStrip(wallSegments), leftWall = new THREE.Mesh(leftWallGeometry, volumeMaterial); scene.add(leftWall);
    const rightWallGeometry = createWallStrip(wallSegments), rightWall = new THREE.Mesh(rightWallGeometry, volumeMaterial); scene.add(rightWall);

    const heliGroup = new THREE.Group();
    heliGroup.position.set(0, 50, 0);
    heliGroup.scale.set(2, 2, 2);
    scene.add(heliGroup);

    function createFallbackShip() {
      const fuselageMat = new THREE.MeshStandardMaterial({ color: 0x2a1a3a, metalness: 0.8, roughness: 0.3, emissive: 0x1a0a2a, emissiveIntensity: 0.2 });
      const fuselageGeom = new THREE.SphereGeometry(3, 16, 12);
      const fuselage = new THREE.Mesh(fuselageGeom, fuselageMat);
      fuselage.scale.set(3, 1, 1);
      heliGroup.add(fuselage);

      const cockpitMat = new THREE.MeshStandardMaterial({ color: 0x4488ff, metalness: 0.9, roughness: 0.1, emissive: 0x2244aa, emissiveIntensity: 0.3 });
      const cockpit = new THREE.Mesh(new THREE.SphereGeometry(1.5, 12, 8), cockpitMat);
      cockpit.position.set(5, 0.5, 0);
      cockpit.scale.set(1.5, 0.8, 1);
      heliGroup.add(cockpit);

      const wingMat = new THREE.MeshStandardMaterial({ color: 0x3a2a4a, metalness: 0.7, roughness: 0.4 });
      const wingGeom = new THREE.BoxGeometry(6, 0.4, 12);
      const wings = new THREE.Mesh(wingGeom, wingMat);
      wings.position.set(-2, 0, 0);
      heliGroup.add(wings);

      const tailGeom = new THREE.BoxGeometry(4, 4, 0.4);
      const tailV = new THREE.Mesh(tailGeom, wingMat);
      tailV.position.set(-7, 2, 0);
      heliGroup.add(tailV);
      const tailH = new THREE.Mesh(new THREE.BoxGeometry(2, 0.4, 6), wingMat);
      tailH.position.set(-7, 0, 0);
      heliGroup.add(tailH);

      const engineMat = new THREE.MeshBasicMaterial({ color: 0xFF6600 });
      const engine1 = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 2, 8), engineMat);
      engine1.rotation.z = Math.PI / 2;
      engine1.position.set(-10, 0, 2);
      heliGroup.add(engine1);
      const engine2 = engine1.clone();
      engine2.position.set(-10, 0, -2);
      heliGroup.add(engine2);
    }

    createFallbackShip();

    const loader = new THREE.GLTFLoader();
    loader.load('https://vazxmixjsiawhamofees.supabase.co/storage/v1/object/public/models/low-poly-spaceship/model.gltf',
      (gltf) => {
        while(heliGroup.children.length > 0) heliGroup.remove(heliGroup.children[0]);
        const shipModel = gltf.scene;
        const box = new THREE.Box3().setFromObject(shipModel);
        const size = box.getSize(new THREE.Vector3());
        const scale = 25 / Math.max(size.x, size.y, size.z);
        shipModel.scale.set(scale, scale, scale);
        const center = box.getCenter(new THREE.Vector3());
        shipModel.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
        shipModel.rotation.y = Math.PI / 2;
        heliGroup.add(shipModel);
      },
      () => {},
      () => {}
    );

    const animalGroup = new THREE.Group();
    const polarBearMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F5, roughness: 0.8 });
    const penguinBodyMat = new THREE.MeshStandardMaterial({ color: 0x212121, roughness: 0.6 });
    const penguinBellyMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.7 });
    const animalStep = isMobile ? 60 : 35;
    for (let x = -80; x <= 80; x += animalStep) {
      for (let z = -80; z <= 80; z += animalStep) {
        const animalObj = new THREE.Group();
        const px = x + (Math.random() - 0.5) * 20, pz = z + (Math.random() - 0.5) * 20;
        if (Math.random() > 0.5) {
          const body = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 4), polarBearMat); body.position.y = 1; animalObj.add(body);
          const head = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.8), polarBearMat); head.position.set(0, 1.2, 2.5); animalObj.add(head);
        } else {
          const body = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 8), penguinBodyMat); body.scale.y = 1.5; body.position.y = 1.2; animalObj.add(body);
          const belly = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), penguinBellyMat); belly.scale.y = 1.3; belly.position.set(0, 1.2, 0.4); animalObj.add(belly);
        }
        animalObj.userData = { initialX: px, initialZ: pz };
        animalObj.position.set(px, getTerrainHeight(px, pz), pz);
        animalObj.rotation.y = Math.random() * Math.PI * 2;
        animalGroup.add(animalObj);
      }
    }
    animalGroup.visible = false;
    scene.add(animalGroup);

    const keyLight = new THREE.DirectionalLight(0x00CED1, 1.0);
    keyLight.position.set(80, 200, 120);
    scene.add(keyLight);
    const fillLight = new THREE.DirectionalLight(0xE8A87C, 0.5);
    fillLight.position.set(-120, 120, -80);
    scene.add(fillLight);
    const ambientLight = new THREE.AmbientLight(0x00CED1, 0.6);
    scene.add(ambientLight);

    let time = 0, scrollOffset = 0;
    const scrollSpeed = 32;
    
    let barrelRollActive = false;
    let barrelRollProgress = 0;
    const barrelRollDuration = 1.2;

    function updateWalls() {
      const halfSize = terrainSize / 2;
      [[frontWallGeometry, halfSize, true], [backWallGeometry, -halfSize, true], [leftWallGeometry, -halfSize, false], [rightWallGeometry, halfSize, false]].forEach(([geom, coord, isZ]) => {
        const arr = geom.attributes.position.array;
        for (let i = 0; i < wallSegments; i++) {
          const t = i / (wallSegments - 1);
          const primary = -halfSize + t * terrainSize;
          const x = isZ ? primary : coord, z = isZ ? coord : primary;
          const height = getTerrainHeight(x + scrollOffset, z);
          arr[i * 6] = x; arr[i * 6 + 1] = height; arr[i * 6 + 2] = z;
          arr[i * 6 + 3] = x; arr[i * 6 + 4] = -volumeDepth; arr[i * 6 + 5] = z;
        }
        geom.attributes.position.needsUpdate = true;
        geom.computeVertexNormals();
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;
      scrollOffset += scrollSpeed * 0.016;

      terrainMaterial.uniforms.time.value = time;
      terrainMaterial.uniforms.scrollOffset.value = scrollOffset;

      for (let i = 0; i < pos.length; i += 3) pos[i + 1] = getTerrainHeight(pos[i] + scrollOffset, pos[i + 2]);
      posAttr.needsUpdate = true;
      terrainGeometry.computeVertexNormals();

      updateWalls();

      if (animalGroup.visible) {
        animalGroup.children.forEach(a => {
          let newX = a.userData.initialX - (scrollOffset % (terrainSize * 2));
          while (newX < -terrainSize / 2) newX += terrainSize;
          while (newX > terrainSize / 2) newX -= terrainSize;
          a.position.set(newX, getTerrainHeight(a.userData.initialX, a.userData.initialZ), a.userData.initialZ);
        });
      }

      // Base position
      let baseX = Math.sin(time * 0.8) * 30 + Math.sin(time * 1.6) * 15;
      let baseZ = Math.sin(time * 0.7) * 22 + Math.cos(time * 1.2) * 12;
      let baseY = 50 + Math.sin(time * 0.9) * 10 + Math.sin(time * 2.2) * 4;
      
      let rollAngle = Math.sin(time * 0.4) * 0.06;
      let pitchAngle = Math.sin(time * 0.7) * 0.12;
      let yawAngle = Math.sin(time * 0.5) * 0.2;
      
      // Barrel roll - forward loop
      if (barrelRollActive) {
        barrelRollProgress += 0.016 / barrelRollDuration;
        if (barrelRollProgress >= 1.0) {
          barrelRollProgress = 0;
          barrelRollActive = false;
        } else {
          const t = barrelRollProgress;
          const loopAngle = t * Math.PI * 2;
          const loopRadius = 30;
          baseY += Math.sin(loopAngle) * loopRadius;
          baseZ += (1 - Math.cos(loopAngle)) * loopRadius;
          pitchAngle = -loopAngle;
        }
      }
      
      heliGroup.position.x = baseX;
      heliGroup.position.y = baseY;
      heliGroup.position.z = baseZ;
      heliGroup.rotation.y = yawAngle;
      heliGroup.rotation.x = pitchAngle;
      heliGroup.rotation.z = rollAngle;

      document.getElementById('altitude').textContent = Math.floor(heliGroup.position.y * 10 + 500).toString().padStart(4, '0');
      document.getElementById('speed').textContent = Math.floor(150 + Math.sin(time) * 20).toString().padStart(3, '0');
      document.getElementById('heading').textContent = Math.floor((Math.atan2(Math.sin(time * 0.3), Math.cos(time * 0.3)) * 180 / Math.PI + 360) % 360).toString().padStart(3, '0');
      document.getElementById('lat').textContent = (47.3892 + time * 0.01).toFixed(4);
      document.getElementById('lon').textContent = (-122.4821 + time * 0.0001).toFixed(4);

      renderer.render(scene, camera);
    }

    function updateRendererSize() {
      const container = document.getElementById('canvas-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }
    
    window.addEventListener('resize', updateRendererSize);
    setTimeout(updateRendererSize, 0);

    const themes = {
      desert: {
        background: 0x00CED1, fog: 0x00CED1, title: 'DESERT RECON // XS-4',
        colorSand: new THREE.Color(0xDEB8A0), colorDune: new THREE.Color(0xE8A87C), colorPeak: new THREE.Color(0x8B2942),
        volumeBase: new THREE.Color(0x2F8B7B), volumeGrid: new THREE.Color(0x00FFFF),
        keyLightColor: 0xFFFFFF, fillLightColor: 0xE8A87C, ambientColor: 0x00CED1,
        hasRivers: false, riverColor: new THREE.Color(0x00FFFF),
        hudColor: '#E8A87C', hudTitleColor: '#8B2942', hudLabelColor: '#DEB8A0', hudValueColor: '#00FFFF',
        showAnimals: false
      },
      arctic: {
        background: 0xB0E0E6, fog: 0xC4D4E0, title: 'ARCTIC RECON // XS-4',
        colorSand: new THREE.Color(0xD6E5F0), colorDune: new THREE.Color(0xF0F8FF), colorPeak: new THREE.Color(0x4A6B8A),
        volumeBase: new THREE.Color(0x5D6D7E), volumeGrid: new THREE.Color(0x7FFFD4),
        keyLightColor: 0xF0F8FF, fillLightColor: 0xB0E0E6, ambientColor: 0xE6F2F7,
        hasRivers: true, riverColor: new THREE.Color(0xA8C8DC),
        hudColor: '#4A6B8A', hudTitleColor: '#2C3E50', hudLabelColor: '#A8C8DC', hudValueColor: '#7FFFD4',
        showAnimals: true
      },
      jungle: {
        background: 0xA8BF6A, fog: 0xC9B458, title: 'JUNGLE RECON // XS-4',
        colorSand: new THREE.Color(0xD4A857), colorDune: new THREE.Color(0xC46A41), colorPeak: new THREE.Color(0x1B4D3E),
        volumeBase: new THREE.Color(0x7A6840), volumeGrid: new THREE.Color(0x39FF14),
        keyLightColor: 0xC9B458, fillLightColor: 0xA8BF6A, ambientColor: 0xA8BF6A,
        hasRivers: true, riverColor: new THREE.Color(0x0277BD),
        hudColor: '#6B8E23', hudTitleColor: '#1B4D3E', hudLabelColor: '#C46A41', hudValueColor: '#39FF14',
        showAnimals: false
      }
    };

    function applyTheme(themeName) {
      const t = themes[themeName];
      renderer.setClearColor(t.background);
      scene.fog.color.setHex(t.fog);
      terrainMaterial.uniforms.colorSand.value = t.colorSand;
      terrainMaterial.uniforms.colorDune.value = t.colorDune;
      terrainMaterial.uniforms.colorPeak.value = t.colorPeak;
      terrainMaterial.uniforms.hasRivers.value = t.hasRivers ? 1.0 : 0.0;
      terrainMaterial.uniforms.riverColor.value = t.riverColor;
      volumeMaterial.uniforms.baseColor.value = t.volumeBase;
      volumeMaterial.uniforms.gridColor.value = t.volumeGrid;
      keyLight.color.setHex(t.keyLightColor);
      fillLight.color.setHex(t.fillLightColor);
      ambientLight.color.setHex(t.ambientColor);
      animalGroup.visible = t.showAnimals;
      document.querySelector('.hud-top-left .title').textContent = `â—ˆ ${t.title}`;
      document.querySelectorAll('.hud').forEach(h => h.style.color = t.hudColor);
      document.querySelectorAll('.title').forEach(h => h.style.color = t.hudTitleColor);
      document.querySelectorAll('.label').forEach(h => h.style.color = t.hudLabelColor);
      document.querySelectorAll('.value').forEach(h => h.style.color = t.hudValueColor);
      document.querySelectorAll('.theme-btn').forEach(b => { b.classList.remove('active'); if (b.dataset.theme === themeName) b.classList.add('active'); });
    }

    document.querySelectorAll('.theme-btn[data-theme]').forEach(btn => btn.addEventListener('click', () => applyTheme(btn.dataset.theme)));
    
    document.getElementById('barrel-roll-btn').addEventListener('click', () => {
      if (!barrelRollActive) {
        barrelRollActive = true;
        barrelRollProgress = 0;
      }
    });

    updateWalls();
    animate();
  </script>
</body>
</html>