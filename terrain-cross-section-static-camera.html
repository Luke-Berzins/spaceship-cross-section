<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>XS-4 Terrain Scanner</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #FFE4B5;
      overflow: hidden;
      font-family: 'Share Tech Mono', monospace;
      -webkit-font-smoothing: antialiased;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }

    #canvas-container {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    canvas { display: block; }

    .hud {
      position: fixed;
      color: #8B4513;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 2px;
      pointer-events: none;
      text-shadow: 0 0 8px rgba(0,0,0,0.8), 0 2px 4px rgba(0,0,0,0.6);
      background: rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(8px);
      padding: 15px;
      border-radius: 8px;
      z-index: 101;
    }

    .hud-top-left { top: 20px; left: 20px; }
    .hud-top-right { top: 20px; right: 20px; text-align: right; }
    .hud-bottom-left { bottom: 80px; left: 20px; }

    @media (max-width: 768px) {
      .hud {
        font-size: 10px;
        letter-spacing: 1px;
        padding: 10px;
      }
      .hud-top-left { top: 10px; left: 10px; }
      .hud-top-right { top: 10px; right: 10px; }
      .hud-bottom-left { bottom: 70px; left: 10px; }
    }

    .title {
      font-family: 'Orbitron', sans-serif;
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 10px;
      color: #654321;
      text-shadow: 0 0 10px rgba(0,0,0,0.9), 0 2px 6px rgba(0,0,0,0.7);
    }

    .data-row { margin: 5px 0; opacity: 1.0; }
    .label {
      color: #A0826D;
      font-weight: 600;
      text-shadow: 0 0 8px rgba(0,0,0,0.8);
    }
    .value {
      color: #CD853F;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(0,0,0,0.8);
    }

    @media (max-width: 768px) {
      .title {
        font-size: 13px;
        margin-bottom: 8px;
      }
      .data-row { margin: 4px 0; }
    }

    .scanline {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.005) 2px,
        rgba(0, 0, 0, 0.005) 4px
      );
      z-index: 100;
    }

    .vignette {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.08) 100%);
      z-index: 99;
    }

    .theme-controls {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      z-index: 101;
    }

    .theme-btn {
      padding: 18px 40px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 2px;
      border: 3px solid;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 700;
      border-radius: 4px;
    }

    @media (max-width: 768px) {
      .theme-controls {
        gap: 10px;
        bottom: 20px;
      }
      .theme-btn {
        padding: 16px 24px;
        font-size: 12px;
        min-height: 44px;
      }
    }

    .theme-btn.desert {
      border-color: #FF8800;
      color: #FF8800;
    }

    .theme-btn.jungle {
      border-color: #00FF88;
      color: #00FF88;
    }

    .theme-btn.arctic {
      border-color: #00DDFF;
      color: #00DDFF;
    }

    .theme-btn.active {
      transform: scale(1.08);
      background: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 20px currentColor, 0 4px 12px rgba(0,0,0,0.5);
    }

    .theme-btn:hover {
      transform: translateY(-3px);
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 15px currentColor, 0 6px 16px rgba(0,0,0,0.4);
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div class="scanline"></div>
  <div class="vignette"></div>

  <div class="hud hud-top-left">
    <div class="title">◈ DESERT RECON // XS-4</div>
    <div class="data-row"><span class="label">ALT:</span> <span class="value" id="altitude">0000</span>m</div>
    <div class="data-row"><span class="label">SPD:</span> <span class="value" id="speed">000</span>km/h</div>
    <div class="data-row"><span class="label">HDG:</span> <span class="value" id="heading">000</span>°</div>
  </div>

  <div class="hud hud-top-right">
    <div class="title">STATUS ◈</div>
    <div class="data-row"><span class="label">SYSTEM:</span> <span class="value">ONLINE</span></div>
    <div class="data-row"><span class="label">MODE:</span> <span class="value">RECON</span></div>
  </div>

  <div class="hud hud-bottom-left">
    <div class="data-row"><span class="label">LAT:</span> <span class="value" id="lat">47.3892</span>°N</div>
    <div class="data-row"><span class="label">LON:</span> <span class="value" id="lon">-122.4821</span>°W</div>
  </div>

  <div class="theme-controls">
    <button class="theme-btn desert active" data-theme="desert">Desert</button>
    <button class="theme-btn jungle" data-theme="jungle">Jungle</button>
    <button class="theme-btn arctic" data-theme="arctic">Arctic</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    // Simplex noise implementation (cleaned)
    const SimplexNoise = (function () {
      const F2 = 0.5 * (Math.sqrt(3) - 1);
      const G2 = (3 - Math.sqrt(3)) / 6;

      const grad3 = [
        [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
        [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
        [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
      ];

      class SimplexNoise {
        constructor(seed = Math.random()) {
          this.p = new Uint8Array(256);
          this.perm = new Uint8Array(512);
          this.permMod12 = new Uint8Array(512);

          for (let i = 0; i < 256; i++) this.p[i] = i;

          let n, q;
          for (let i = 255; i > 0; i--) {
            seed = (seed * 16807) % 2147483647;
            n = seed % (i + 1);
            q = this.p[i];
            this.p[i] = this.p[n];
            this.p[n] = q;
          }

          for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
            this.permMod12[i] = this.perm[i] % 12;
          }
        }

        noise2D(x, y) {
          const s = (x + y) * F2;
          const i = Math.floor(x + s);
          const j = Math.floor(y + s);
          const t = (i + j) * G2;
          const X0 = i - t;
          const Y0 = j - t;
          const x0 = x - X0;
          const y0 = y - Y0;

          let i1, j1;
          if (x0 > y0) { i1 = 1; j1 = 0; }
          else { i1 = 0; j1 = 1; }

          const x1 = x0 - i1 + G2;
          const y1 = y0 - j1 + G2;
          const x2 = x0 - 1 + 2 * G2;
          const y2 = y0 - 1 + 2 * G2;

          const ii = i & 255;
          const jj = j & 255;

          let n0 = 0, n1 = 0, n2 = 0;

          let t0 = 0.5 - x0 * x0 - y0 * y0;
          if (t0 >= 0) {
            const gi0 = this.permMod12[ii + this.perm[jj]];
            t0 *= t0;
            n0 = t0 * t0 * (grad3[gi0][0] * x0 + grad3[gi0][1] * y0);
          }

          let t1 = 0.5 - x1 * x1 - y1 * y1;
          if (t1 >= 0) {
            const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];
            t1 *= t1;
            n1 = t1 * t1 * (grad3[gi1][0] * x1 + grad3[gi1][1] * y1);
          }

          let t2 = 0.5 - x2 * x2 - y2 * y2;
          if (t2 >= 0) {
            const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];
            t2 *= t2;
            n2 = t2 * t2 * (grad3[gi2][0] * x2 + grad3[gi2][1] * y2);
          }

          return 70 * (n0 + n1 + n2);
        }
      }

      return SimplexNoise;
    })();

    // Scene
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    // Light fog
    scene.fog = new THREE.FogExp2(0xf8f9fa, 0);

    // Camera: isometric perspective showing terrain from elevated corner angle
    // 45-degree view showing both top surface and cross-section sides
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 4000);
    camera.position.set(-200, 200, 200);
    camera.lookAt(0, 0, 0);

    // Renderer with mobile optimization
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
    const renderer = new THREE.WebGLRenderer({
      antialias: !isMobile, // Disable antialiasing on mobile for performance
      powerPreference: isMobile ? 'low-power' : 'high-performance'
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    // Lower pixel ratio on mobile for better performance
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, isMobile ? 1.5 : 2));
    renderer.setClearColor(0xFFE4B5);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.shadowMap.enabled = !isMobile; // Disable shadows on mobile for performance
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // Noise
    const simplex = new SimplexNoise(42);

    // Terrain parameters - reduce segments on mobile for performance
    const terrainSize = 200;
    const terrainSegments = isMobile ? 96 : 192; // Half resolution on mobile
    const terrainHeight = 25; // More dramatic height variation

    function getTerrainHeight(x, z) {
      let height = 0;
      const scale = 0.018;

      // Multi-octave noise for more defined features
      height += simplex.noise2D(x * scale, z * scale) * 1.0;
      height += simplex.noise2D(x * scale * 2.5, z * scale * 2.5) * 0.5;
      height += simplex.noise2D(x * scale * 5, z * scale * 5) * 0.25;
      height += simplex.noise2D(x * scale * 10, z * scale * 10) * 0.125;

      // Add some sharpness to peaks
      height = Math.pow(Math.abs(height), 0.9) * Math.sign(height);

      let finalHeight = height * terrainHeight;

      // Create flat areas at lower elevations (valleys become flat ground)
      // These will become rivers/ice depending on theme
      const valleyFloor = -5.0; // Elevation of flat valley floor
      const valleyThreshold = -2.0; // Start flattening below this height

      if (finalHeight < valleyThreshold) {
        // Smooth transition to flat valley floor
        const transitionFactor = (valleyThreshold - finalHeight) / (valleyThreshold - valleyFloor);
        const smoothFactor = Math.min(1.0, transitionFactor);
        finalHeight = finalHeight * (1.0 - smoothFactor) + valleyFloor * smoothFactor;
      }

      return finalHeight;
    }

    // Terrain geometry
    const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
    terrainGeometry.rotateX(-Math.PI / 2);

    const posAttr = terrainGeometry.attributes.position;
    const pos = posAttr.array;

    // Seed initial heights
    (function initTerrain() {
      for (let i = 0; i < pos.length; i += 3) {
        const x = pos[i];
        const z = pos[i + 2];
        pos[i + 1] = getTerrainHeight(x, z);
      }
      posAttr.needsUpdate = true;
      terrainGeometry.computeVertexNormals();
      terrainGeometry.attributes.normal.needsUpdate = true;
    })();

    // Terrain material (shader) — Desert colors
    const terrainMaterial = new THREE.ShaderMaterial({
      uniforms: {
        sliceX: { value: 0 },
        sliceWidth: { value: 2.25 },
        time: { value: 0 },
        scrollOffset: { value: 0 },  // For fixed river positions
        colorSand: { value: new THREE.Color(0xDEB887) },    // Burlywood
        colorDune: { value: new THREE.Color(0xF4A460) },    // Sandy brown
        colorPeak: { value: new THREE.Color(0xCD853F) },    // Peru
        sliceColor: { value: new THREE.Color(0xD2691E) },   // Chocolate
        gridColor: { value: new THREE.Color(0xC19A6B) },     // Camel
        hasRivers: { value: 0.0 },
        riverColor: { value: new THREE.Color(0x0277BD) }
      },
      vertexShader: `
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying float vElevation;

        void main() {
          vPosition = position;
          vNormal = normal;
          vElevation = position.y;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float sliceX;
        uniform float sliceWidth;
        uniform float time;
        uniform float scrollOffset;
        uniform vec3 colorSand;
        uniform vec3 colorDune;
        uniform vec3 colorPeak;
        uniform vec3 sliceColor;
        uniform vec3 gridColor;
        uniform float hasRivers;
        uniform vec3 riverColor;

        varying vec3 vPosition;
        varying vec3 vNormal;
        varying float vElevation;

        // Simple hash function for pseudo-random values
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        void main() {
          // Color gradient based on height
          float heightFactor = clamp((vElevation + 20.0) / 40.0, 0.0, 1.0);

          // Three-color gradient: valleys -> mid -> peaks
          vec3 color;
          if (heightFactor < 0.5) {
            color = mix(colorSand, colorDune, heightFactor * 2.0);
          } else {
            color = mix(colorDune, colorPeak, (heightFactor - 0.5) * 2.0);
          }

          // Dense rainforest canopy with life-algorithm pattern (for jungle theme)
          if (hasRivers > 0.5) {
            // Calculate scrolled position so forest moves with topology
            vec2 scrolledPos = vec2(vPosition.x + scrollOffset, vPosition.z);

            // Only place trees above valley floor (avoid flat water/ice areas)
            float notOnValleyFloor = smoothstep(-6.0, -3.0, vElevation);

            // Life-algorithm inspired cellular pattern for natural tree clustering
            // Check neighboring cells at multiple scales
            vec2 cellSize = vec2(16.0); // Larger cells for bigger color patches
            vec2 cellCoord = floor(scrolledPos / cellSize);

            // Count "alive" neighbors (cells with trees)
            float neighbors = 0.0;
            for (float dx = -1.0; dx <= 1.0; dx += 1.0) {
              for (float dz = -1.0; dz <= 1.0; dz += 1.0) {
                if (dx == 0.0 && dz == 0.0) continue;
                vec2 neighborCell = cellCoord + vec2(dx, dz);
                float neighborValue = hash(neighborCell);
                if (neighborValue > 0.2) neighbors += 1.0; // Neighbor has trees
              }
            }

            // Life-like rules: trees grow in dense clusters
            float cellValue = hash(cellCoord);
            float lifePattern = 0.0;

            // Very dense growth: cells with 2-7 neighbors become trees
            if (neighbors >= 2.0 && neighbors <= 7.0) {
              lifePattern = 1.0;
            } else if (neighbors >= 1.0 && cellValue > 0.25) {
              lifePattern = 0.9;
            }

            // Add micro-scale variation within cells (using scrolled position)
            // Smooth interpolation within cells to reduce flickering
            vec2 cellFract = fract(scrolledPos / cellSize);
            float cellSmooth = cellFract.x * cellFract.y * (1.0 - cellFract.x) * (1.0 - cellFract.y) * 16.0;

            float microDetail = hash(cellCoord + vec2(0.5));
            float withinCellVariation = mix(0.5, 1.0, smoothstep(0.2, 0.8, microDetail + cellSmooth * 0.1));

            // Combine life pattern with within-cell detail for very dense coverage
            float forestCoverage = lifePattern * withinCellVariation * notOnValleyFloor;
            forestCoverage = smoothstep(0.2, 0.8, forestCoverage);

            // DARK green shading - much darker than base terrain
            // Lower elevations get much darker
            float elevationDarkness = smoothstep(-10.0, 10.0, vElevation);
            elevationDarkness = pow(elevationDarkness, 0.7); // Strong valley darkening

            // Very dark greens - emphasizing darkness
            vec3 darkGreen1 = colorSand * (0.12 + elevationDarkness * 0.08);  // Very dark dense canopy
            vec3 darkGreen2 = colorSand * (0.20 + elevationDarkness * 0.12);  // Dark medium canopy
            vec3 darkGreen3 = colorSand * (0.30 + elevationDarkness * 0.15);  // Dark lighter areas

            // Choose green shade based on neighbor density (more neighbors = darker/denser)
            vec3 forestColor;
            if (neighbors >= 5.0) {
              forestColor = darkGreen1; // Very dense clusters - darkest
            } else if (neighbors >= 3.0) {
              forestColor = darkGreen2; // Medium density
            } else {
              forestColor = darkGreen3; // Edge of forest
            }

            // Apply very dense forest coverage
            color = mix(color, forestColor, forestCoverage * 0.95);
          }

          // Rivers (jungle) / Ice (arctic) - cover flat valley floors
          if (hasRivers > 0.5) {
            // Calculate scrolled position so water/ice moves with topology
            vec2 scrolledPos = vec2(vPosition.x + scrollOffset, vPosition.z);

            // Flat valley floors (rivers in jungle, ice in arctic)
            // Strong transition for flat areas around -5.0 elevation
            float isValleyFloor = smoothstep(-3.5, -5.5, vElevation);

            // Add subtle variation for natural appearance
            // Using larger cells to avoid flickering
            float surfaceVariation = hash(floor(scrolledPos / 20.0)) * 0.15 + 0.85;

            // Apply water/ice color to flat valley floors
            float surfaceMask = isValleyFloor * surfaceVariation;
            vec3 surfaceColor = riverColor * (0.85 + sin(time * 0.5) * 0.1);
            color = mix(color, surfaceColor, surfaceMask * 0.98);
          }

          // Lighting
          vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
          float diffuse = max(dot(vNormal, lightDir), 0.0);
          float ambient = 0.7;
          float lit = ambient + diffuse * 0.4;

          gl_FragColor = vec4(color * lit, 1.0);
        }
      `,
      side: THREE.DoubleSide
    });

    const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
    terrain.receiveShadow = !isMobile;
    terrain.castShadow = !isMobile;
    scene.add(terrain);

    // Create filled volume underneath terrain
    const volumeDepth = 50; // How deep the filled volume goes
    const volumeMaterial = new THREE.ShaderMaterial({
      uniforms: {
        baseColor: { value: new THREE.Color(0xC19A6B) },  // Camel
        gridColor: { value: new THREE.Color(0x8B7355) }   // Burlywood darker
      },
      vertexShader: `
        varying vec3 vPosition;
        varying vec3 vNormal;

        void main() {
          vPosition = position;
          vNormal = normal;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 baseColor;
        uniform vec3 gridColor;

        varying vec3 vPosition;
        varying vec3 vNormal;

        void main() {
          // Grid
          float gridSize = 4.0;
          vec2 grid = abs(fract(vPosition.xy / gridSize - 0.5) - 0.5) / fwidth(vPosition.xy / gridSize);
          float gridLine = min(grid.x, grid.y);
          float gridMask = 1.0 - min(gridLine, 1.0);

          vec3 color = mix(baseColor, gridColor, gridMask * 0.15);

          // Lighting
          vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
          float diffuse = max(dot(vNormal, lightDir), 0.0);
          float ambient = 0.7;
          float lit = ambient + diffuse * 0.4;

          gl_FragColor = vec4(color * lit, 1.0);
        }
      `,
      side: THREE.DoubleSide
    });

    // Bottom plane
    const bottomGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize);
    bottomGeometry.rotateX(-Math.PI / 2);
    const bottomPlane = new THREE.Mesh(bottomGeometry, volumeMaterial);
    bottomPlane.position.y = -volumeDepth;
    scene.add(bottomPlane);

    // Side walls - dynamic geometries that follow terrain contour
    const wallHeight = volumeDepth;
    const wallSegments = isMobile ? 64 : 128; // Reduce segments on mobile

    // Create strip geometries for each side
    function createWallStrip(samples) {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(samples * 2 * 3);
      const normals = new Float32Array(samples * 2 * 3);
      const indices = [];

      for (let i = 0; i < samples - 1; i++) {
        const a = i * 2;
        const b = i * 2 + 1;
        const c = (i + 1) * 2;
        const d = (i + 1) * 2 + 1;

        indices.push(a, b, c);
        indices.push(b, d, c);
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
      geometry.setIndex(indices);
      return geometry;
    }

    // Front wall (positive Z)
    const frontWallGeometry = createWallStrip(wallSegments);
    const frontWall = new THREE.Mesh(frontWallGeometry, volumeMaterial);
    scene.add(frontWall);

    // Back wall (negative Z)
    const backWallGeometry = createWallStrip(wallSegments);
    const backWall = new THREE.Mesh(backWallGeometry, volumeMaterial);
    scene.add(backWall);

    // Left wall (negative X)
    const leftWallGeometry = createWallStrip(wallSegments);
    const leftWall = new THREE.Mesh(leftWallGeometry, volumeMaterial);
    scene.add(leftWall);

    // Right wall (positive X)
    const rightWallGeometry = createWallStrip(wallSegments);
    const rightWall = new THREE.Mesh(rightWallGeometry, volumeMaterial);
    scene.add(rightWall);

    // Cross-section line (in-world) - Hidden (scanning element removed)
    const sliceLineGeometry = new THREE.BufferGeometry();
    const sliceLinePoints = new Float32Array(512 * 3);
    sliceLineGeometry.setAttribute('position', new THREE.BufferAttribute(sliceLinePoints, 3));
    const sliceLineMaterial = new THREE.LineBasicMaterial({ color: 0xD2691E, linewidth: 2 }); // Chocolate
    const sliceLine = new THREE.Line(sliceLineGeometry, sliceLineMaterial);
    sliceLine.visible = false; // Hidden - scanning element removed
    scene.add(sliceLine);

    // Slice plane (scan sheet)
    const slicePlaneGeometry = new THREE.PlaneGeometry(terrainSize, 60);
    const slicePlaneMaterial = new THREE.ShaderMaterial({
      uniforms: { time: { value: 0 } },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        varying vec2 vUv;

        void main() {
          float scanLine = sin(vUv.y * 100.0 + time * 5.0) * 0.5 + 0.5;
          float edge = smoothstep(0.0, 0.02, vUv.x) * smoothstep(1.0, 0.98, vUv.x);

          float alpha = 0.05 + scanLine * 0.02;
          alpha *= edge;
          alpha *= smoothstep(0.0, 0.3, vUv.y) * smoothstep(1.0, 0.7, vUv.y);

          vec3 color = vec3(0.82, 0.41, 0.12); // Chocolate brown
          gl_FragColor = vec4(color, alpha);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false
    });

    const slicePlane = new THREE.Mesh(slicePlaneGeometry, slicePlaneMaterial);
    slicePlane.rotation.y = Math.PI / 2;
    slicePlane.position.y = 15;
    slicePlane.visible = false; // Hidden - scanning element removed
    scene.add(slicePlane);

    // Spaceship - loaded from GLTF model
    const heliGroup = new THREE.Group();
    let shipModel = null;
    let shipLoaded = false;

    // Position the group
    heliGroup.position.set(0, 50, 0);
    scene.add(heliGroup);

    // Load GLTF spaceship model
    const loader = new THREE.GLTFLoader();

    // Free sci-fi spaceship model (CC0 license)
    // Using a sleek sci-fi ship from Sketchfab/free sources
    const shipModelURL = 'https://vazxmixjsiawhamofees.supabase.co/storage/v1/object/public/models/low-poly-spaceship/model.gltf';

    loader.load(
      shipModelURL,
      function (gltf) {
        shipModel = gltf.scene;

        // Calculate bounding box to properly scale and center
        const box = new THREE.Box3().setFromObject(shipModel);
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 25 / maxDim; // Scale to reasonable size

        shipModel.scale.set(scale, scale, scale);

        // Center the model
        const center = box.getCenter(new THREE.Vector3());
        shipModel.position.set(-center.x * scale, -center.y * scale, -center.z * scale);

        // Rotate to face the right direction
        shipModel.rotation.y = Math.PI / 2;

        // Enable shadows on all meshes
        shipModel.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = !isMobile;
            child.receiveShadow = !isMobile;
          }
        });

        heliGroup.add(shipModel);
        shipLoaded = true;
        console.log('Spaceship model loaded successfully!');
      },
      function (xhr) {
        console.log('Loading spaceship: ' + (xhr.loaded / xhr.total * 100).toFixed(0) + '%');
      },
      function (error) {
        console.error('Error loading spaceship model:', error);
        // Fallback: create a simple sleek shape using LatheGeometry
        createFallbackShip();
      }
    );

    // Fallback ship using LatheGeometry for a smooth fuselage
    function createFallbackShip() {
      const points = [];
      // Create a sleek teardrop/fuselage profile
      for (let i = 0; i <= 20; i++) {
        const t = i / 20;
        // Teardrop curve: wider at back, tapered at front
        const x = t * 12 - 6; // -6 to 6 (length)
        let r;
        if (t < 0.7) {
          // Front taper
          r = Math.sin(t / 0.7 * Math.PI * 0.5) * 1.5;
        } else {
          // Back bulge then taper
          r = Math.cos((t - 0.7) / 0.3 * Math.PI * 0.5) * 1.5;
        }
        points.push(new THREE.Vector2(r, x));
      }

      const fuselageGeom = new THREE.LatheGeometry(points, 16);
      const fuselageMat = new THREE.MeshStandardMaterial({
        color: 0x2a1a3a,
        metalness: 0.8,
        roughness: 0.3,
        emissive: 0x1a0a2a,
        emissiveIntensity: 0.2
      });

      const fuselage = new THREE.Mesh(fuselageGeom, fuselageMat);
      fuselage.rotation.z = Math.PI / 2; // Point forward
      fuselage.scale.set(2, 2, 2);

      // Add wing stubs
      const wingMat = new THREE.MeshStandardMaterial({
        color: 0x3a2a4a,
        metalness: 0.7,
        roughness: 0.4
      });

      const wingGeom = new THREE.BoxGeometry(8, 0.3, 3);
      const leftWing = new THREE.Mesh(wingGeom, wingMat);
      leftWing.position.set(0, 0, -4);
      leftWing.rotation.y = -0.2;

      const rightWing = new THREE.Mesh(wingGeom, wingMat);
      rightWing.position.set(0, 0, 4);
      rightWing.rotation.y = 0.2;

      // Engine glow
      const engineMat = new THREE.MeshBasicMaterial({ color: 0xFF6600 });
      const engineGeom = new THREE.CylinderGeometry(0.8, 1.2, 2, 8);
      const engine = new THREE.Mesh(engineGeom, engineMat);
      engine.rotation.z = Math.PI / 2;
      engine.position.set(-8, 0, 0);

      heliGroup.add(fuselage);
      heliGroup.add(leftWing);
      heliGroup.add(rightWing);
      heliGroup.add(engine);

      shipLoaded = true;
      console.log('Fallback ship created');
    }

    // Arctic animals group (polar bears and penguins)
    const animalGroup = new THREE.Group();

    // Materials for animals
    const polarBearMaterial = new THREE.MeshStandardMaterial({
      color: 0xF5F5F5,  // Off-white
      roughness: 0.8,
      metalness: 0.1
    });
    const penguinBodyMaterial = new THREE.MeshStandardMaterial({
      color: 0x212121,  // Black
      roughness: 0.6,
      metalness: 0.2
    });
    const penguinBellyMaterial = new THREE.MeshStandardMaterial({
      color: 0xFFFFFF,  // White
      roughness: 0.7,
      metalness: 0.1
    });

    // Create animal positions (scattered across terrain) - fewer on mobile
    const animalPositions = [];
    const animalStep = isMobile ? 50 : 35; // Larger spacing on mobile = fewer animals
    for (let x = -80; x <= 80; x += animalStep) {
      for (let z = -80; z <= 80; z += animalStep) {
        const offsetX = (Math.random() - 0.5) * 20;
        const offsetZ = (Math.random() - 0.5) * 20;
        const isPolarBear = Math.random() > 0.5;
        animalPositions.push({ x: x + offsetX, z: z + offsetZ, type: isPolarBear ? 'bear' : 'penguin' });
      }
    }

    animalPositions.forEach((pos) => {
      const animalObj = new THREE.Group();

      if (pos.type === 'bear') {
        // Polar bear - simple blocky shape
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(3, 1.5, 4),
          polarBearMaterial
        );
        body.position.y = 1;
        body.castShadow = !isMobile;
        animalObj.add(body);

        // Head
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 1.5, 1.8),
          polarBearMaterial
        );
        head.position.set(0, 1.2, 2.5);
        head.castShadow = !isMobile;
        animalObj.add(head);

        // Legs
        const legGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.5, 6);
        for (let i = 0; i < 4; i++) {
          const leg = new THREE.Mesh(legGeometry, polarBearMaterial);
          leg.position.set(i < 2 ? -1 : 1, 0.75, i % 2 === 0 ? 1.5 : -1);
          leg.castShadow = !isMobile;
          animalObj.add(leg);
        }
      } else {
        // Penguin - simple egg shape with flippers
        const body = new THREE.Mesh(
          new THREE.SphereGeometry(0.8, 8, 8),
          penguinBodyMaterial
        );
        body.scale.y = 1.5;
        body.position.y = 1.2;
        body.castShadow = !isMobile;
        animalObj.add(body);

        // White belly
        const belly = new THREE.Mesh(
          new THREE.SphereGeometry(0.6, 8, 8),
          penguinBellyMaterial
        );
        belly.scale.y = 1.3;
        belly.position.set(0, 1.2, 0.4);
        belly.castShadow = !isMobile;
        animalObj.add(belly);

        // Head
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.5, 8, 8),
          penguinBodyMaterial
        );
        head.position.y = 2.2;
        head.castShadow = !isMobile;
        animalObj.add(head);

        // Flippers
        const flipperGeometry = new THREE.BoxGeometry(0.2, 1, 0.5);
        const leftFlipper = new THREE.Mesh(flipperGeometry, penguinBodyMaterial);
        leftFlipper.position.set(-0.7, 1.2, 0);
        leftFlipper.rotation.z = 0.3;
        leftFlipper.castShadow = !isMobile;
        animalObj.add(leftFlipper);

        const rightFlipper = new THREE.Mesh(flipperGeometry, penguinBodyMaterial);
        rightFlipper.position.set(0.7, 1.2, 0);
        rightFlipper.rotation.z = -0.3;
        rightFlipper.castShadow = !isMobile;
        animalObj.add(rightFlipper);
      }

      // Store initial position for scrolling
      animalObj.userData.initialX = pos.x;
      animalObj.userData.initialZ = pos.z;

      animalObj.position.x = pos.x;
      animalObj.position.z = pos.z;
      animalObj.position.y = getHeightWithWater(pos.x, pos.z);

      // Random rotation
      animalObj.rotation.y = Math.random() * Math.PI * 2;

      animalGroup.add(animalObj);
    });

    animalGroup.visible = false; // Hidden by default, shown in Arctic theme
    scene.add(animalGroup);

    // Lighting (warm desert sun)
    const keyLight = new THREE.DirectionalLight(0xFFE4B5, 1.0); // Warm sandy light
    keyLight.position.set(80, 200, 120);
    keyLight.castShadow = !isMobile;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.left = -150;
    keyLight.shadow.camera.right = 150;
    keyLight.shadow.camera.top = 150;
    keyLight.shadow.camera.bottom = -150;
    keyLight.shadow.camera.near = 0.5;
    keyLight.shadow.camera.far = 500;
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0xF4A460, 0.5); // Sandy brown fill
    fillLight.position.set(-120, 120, -80);
    scene.add(fillLight);

    const ambientLight = new THREE.AmbientLight(0xFFE4B5, 0.6); // Warm ambient
    scene.add(ambientLight);

    // Animation state
    let time = 0;
    let sliceX = -terrainSize / 2;
    const sliceSpeed = 15;
    let scrollOffset = 0;
    const scrollSpeed = 8; // Units per second

    // Get terrain height (flattening is now baked into terrain generation)
    function getHeightWithWater(worldX, worldZ) {
      return getTerrainHeight(worldX, worldZ);
    }

    function updateTerrainMesh() {
      for (let i = 0; i < pos.length; i += 3) {
        const x = pos[i];
        const z = pos[i + 2];
        const worldX = x + scrollOffset;
        const worldZ = z;

        pos[i + 1] = getHeightWithWater(worldX, worldZ);
      }

      posAttr.needsUpdate = true;
      terrainGeometry.computeVertexNormals();
      terrainGeometry.attributes.normal.needsUpdate = true;
    }

    function updateAnimals() {
      // Update animal positions to scroll with terrain
      if (!animalGroup.visible) return; // Skip if animals are hidden

      animalGroup.children.forEach(animal => {
        const initialX = animal.userData.initialX;
        const initialZ = animal.userData.initialZ;

        // Calculate scrolled position (move in opposite direction of scroll)
        // Using modulo for seamless wrapping
        const scrollMod = scrollOffset % (terrainSize * 2);
        let newX = initialX - scrollMod;

        // Wrap around the terrain bounds
        while (newX < -terrainSize / 2) newX += terrainSize;
        while (newX > terrainSize / 2) newX -= terrainSize;

        animal.position.x = newX;
        animal.position.z = initialZ;
        // Update Y position to follow terrain height at scrolled location (with water flattening)
        animal.position.y = getHeightWithWater(initialX, initialZ);
      });
    }

    function updateCrossSection() {
      const samples = 512;
      const startZ = -terrainSize / 2;
      const endZ = terrainSize / 2;

      const arr = sliceLine.geometry.attributes.position.array;

      for (let i = 0; i < samples; i++) {
        const z = startZ + (i / (samples - 1)) * (endZ - startZ);
        const height = getHeightWithWater(sliceX + scrollOffset, z);

        arr[i * 3] = sliceX;
        arr[i * 3 + 1] = height + 1;
        arr[i * 3 + 2] = z;
      }

      sliceLine.geometry.attributes.position.needsUpdate = true;
    }

    function updateWallGeometries() {
      const halfSize = terrainSize / 2;

      // Front wall (positive Z)
      const frontPos = frontWallGeometry.attributes.position.array;
      for (let i = 0; i < wallSegments; i++) {
        const t = i / (wallSegments - 1);
        const x = -halfSize + t * terrainSize;
        const z = halfSize;
        const height = getHeightWithWater(x + scrollOffset, z);

        frontPos[i * 6] = x;
        frontPos[i * 6 + 1] = height;
        frontPos[i * 6 + 2] = z;

        frontPos[i * 6 + 3] = x;
        frontPos[i * 6 + 4] = -volumeDepth;
        frontPos[i * 6 + 5] = z;
      }
      frontWallGeometry.attributes.position.needsUpdate = true;
      frontWallGeometry.computeVertexNormals();
      frontWallGeometry.attributes.normal.needsUpdate = true;

      // Back wall (negative Z)
      const backPos = backWallGeometry.attributes.position.array;
      for (let i = 0; i < wallSegments; i++) {
        const t = i / (wallSegments - 1);
        const x = -halfSize + t * terrainSize;
        const z = -halfSize;
        const height = getHeightWithWater(x + scrollOffset, z);

        backPos[i * 6] = x;
        backPos[i * 6 + 1] = height;
        backPos[i * 6 + 2] = z;

        backPos[i * 6 + 3] = x;
        backPos[i * 6 + 4] = -volumeDepth;
        backPos[i * 6 + 5] = z;
      }
      backWallGeometry.attributes.position.needsUpdate = true;
      backWallGeometry.computeVertexNormals();
      backWallGeometry.attributes.normal.needsUpdate = true;

      // Left wall (negative X)
      const leftPos = leftWallGeometry.attributes.position.array;
      for (let i = 0; i < wallSegments; i++) {
        const t = i / (wallSegments - 1);
        const z = -halfSize + t * terrainSize;
        const x = -halfSize;
        const height = getHeightWithWater(x + scrollOffset, z);

        leftPos[i * 6] = x;
        leftPos[i * 6 + 1] = height;
        leftPos[i * 6 + 2] = z;

        leftPos[i * 6 + 3] = x;
        leftPos[i * 6 + 4] = -volumeDepth;
        leftPos[i * 6 + 5] = z;
      }
      leftWallGeometry.attributes.position.needsUpdate = true;
      leftWallGeometry.computeVertexNormals();
      leftWallGeometry.attributes.normal.needsUpdate = true;

      // Right wall (positive X)
      const rightPos = rightWallGeometry.attributes.position.array;
      for (let i = 0; i < wallSegments; i++) {
        const t = i / (wallSegments - 1);
        const z = -halfSize + t * terrainSize;
        const x = halfSize;
        const height = getHeightWithWater(x + scrollOffset, z);

        rightPos[i * 6] = x;
        rightPos[i * 6 + 1] = height;
        rightPos[i * 6 + 2] = z;

        rightPos[i * 6 + 3] = x;
        rightPos[i * 6 + 4] = -volumeDepth;
        rightPos[i * 6 + 5] = z;
      }
      rightWallGeometry.attributes.position.needsUpdate = true;
      rightWallGeometry.computeVertexNormals();
      rightWallGeometry.attributes.normal.needsUpdate = true;
    }

    function updateHUD() {
      const altitude = Math.floor(heliGroup.position.y * 10 + 500);
      const speed = Math.floor(150 + Math.sin(time) * 20);
      const heading = Math.floor((Math.atan2(Math.sin(time * 0.3), Math.cos(time * 0.3)) * 180 / Math.PI + 360) % 360);

      document.getElementById('altitude').textContent = altitude.toString().padStart(4, '0');
      document.getElementById('speed').textContent = speed.toString().padStart(3, '0');
      document.getElementById('heading').textContent = heading.toString().padStart(3, '0');

      const lat = (47.3892 + time * 0.01).toFixed(4);
      const lon = (-122.4821 + time * 0.0001).toFixed(4);
      document.getElementById('lat').textContent = lat;
      document.getElementById('lon').textContent = lon;
    }

    function animate() {
      requestAnimationFrame(animate);

      const delta = 0.016;
      time += delta;

      // Scroll the topology
      scrollOffset += scrollSpeed * delta;

      // Update uniforms
      terrainMaterial.uniforms.time.value = time;
      terrainMaterial.uniforms.scrollOffset.value = scrollOffset;

      // Terrain animation
      updateTerrainMesh();
      updateWallGeometries();
      updateAnimals();

      // Spaceship motion - dramatic bobbing and sweeping movement
      heliGroup.position.x = Math.sin(time * 0.5) * 25 + Math.sin(time * 1.1) * 10; // Wide left-right sweeps
      heliGroup.position.z = Math.sin(time * 0.4) * 18 + Math.cos(time * 0.8) * 8; // Forward-back drift
      // Dramatic vertical hovering motion
      heliGroup.position.y = 50 + Math.sin(time * 0.6) * 8 + Math.sin(time * 1.8) * 3;

      // Dynamic rotation that follows movement direction - more dramatic banking
      const bobVelocityX = Math.cos(time * 0.5) * 0.5 * 25 + Math.cos(time * 1.1) * 1.1 * 10;
      const bobVelocityZ = Math.cos(time * 0.4) * 0.4 * 18 - Math.sin(time * 0.8) * 0.8 * 8;
      heliGroup.rotation.y = Math.sin(time * 0.35) * 0.15; // More pronounced yaw
      heliGroup.rotation.x = Math.sin(time * 0.5) * 0.08 - bobVelocityZ * 0.015; // Stronger pitch
      heliGroup.rotation.z = Math.sin(time * 0.4) * 0.06 - bobVelocityX * 0.02; // Stronger roll into turns

      // Animate loaded ship model (if applicable)
      if (shipModel) {
        // Could add material animations here if needed
      }

      // Fixed camera (no movement)
      // Keep looking at origin in case aspect changes; no position updates.
      camera.lookAt(0, 0, 0);

      // HUD
      updateHUD();

      renderer.render(scene, camera);
    }

    // Throttled resize handler for better mobile performance
    let resizeTimeout;
    window.addEventListener('resize', () => {
      if (isMobile) {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }, 100);
      } else {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    // Theme configuration
    const themes = {
      desert: {
        background: 0xFFE4B5,
        fog: 0xFFE4B5,
        title: 'DESERT RECON // XS-4',
        colorSand: new THREE.Color(0xDEB887),
        colorDune: new THREE.Color(0xF4A460),
        colorPeak: new THREE.Color(0xCD853F),
        sliceColor: new THREE.Color(0xD2691E),
        gridColor: new THREE.Color(0xC19A6B),
        volumeBase: new THREE.Color(0xC19A6B),
        volumeGrid: new THREE.Color(0x8B7355),
        keyLightColor: 0xFFE4B5,
        fillLightColor: 0xF4A460,
        ambientColor: 0xFFE4B5,
        hasRivers: false,
        hudColor: '#8B4513',
        hudTitleColor: '#654321',
        hudLabelColor: '#A0826D',
        hudValueColor: '#CD853F',
        showAnimals: false
      },
      jungle: {
        background: 0xC8E6C9,
        fog: 0xC8E6C9,
        title: 'JUNGLE RECON // XS-4',
        colorSand: new THREE.Color(0x2E7D32),   // Dark green valleys
        colorDune: new THREE.Color(0x43A047),   // Medium green
        colorPeak: new THREE.Color(0x66BB6A),   // Light green peaks
        sliceColor: new THREE.Color(0x1B5E20),
        gridColor: new THREE.Color(0x81C784),
        volumeBase: new THREE.Color(0x4E342E),  // Brown earth
        volumeGrid: new THREE.Color(0x3E2723),
        keyLightColor: 0xE8F5E9,
        fillLightColor: 0xC8E6C9,
        ambientColor: 0xE8F5E9,
        hasRivers: true,
        riverColor: new THREE.Color(0x0277BD),  // Blue water
        hudColor: '#1B5E20',
        hudTitleColor: '#1B5E20',
        hudLabelColor: '#4CAF50',
        hudValueColor: '#2E7D32',
        showAnimals: false
      },
      arctic: {
        background: 0xE1F5FE,
        fog: 0xE1F5FE,
        title: 'ARCTIC RECON // XS-4',
        colorSand: new THREE.Color(0xB0BEC5),   // Gray-blue valleys
        colorDune: new THREE.Color(0xE3F2FD),   // Light blue ice
        colorPeak: new THREE.Color(0xFFFFFF),   // White snow peaks
        sliceColor: new THREE.Color(0x01579B),
        gridColor: new THREE.Color(0x90CAF9),
        volumeBase: new THREE.Color(0xCFD8DC),  // Light gray ice
        volumeGrid: new THREE.Color(0x90A4AE),
        keyLightColor: 0xE1F5FE,
        fillLightColor: 0xB3E5FC,
        ambientColor: 0xE1F5FE,
        hasRivers: true,
        riverColor: new THREE.Color(0xB3E5FC),  // Icy blue (frozen valley floors)
        hudColor: '#006064',
        hudTitleColor: '#004D40',
        hudLabelColor: '#00838F',
        hudValueColor: '#0097A7',
        showAnimals: true
      }
    };

    let currentTheme = 'desert';

    function applyTheme(themeName) {
      const theme = themes[themeName];
      currentTheme = themeName;

      // Update background
      document.body.style.background = `#${theme.background.toString(16).padStart(6, '0')}`;
      renderer.setClearColor(theme.background);
      scene.fog.color.setHex(theme.fog);

      // Update terrain colors
      terrainMaterial.uniforms.colorSand.value = theme.colorSand;
      terrainMaterial.uniforms.colorDune.value = theme.colorDune;
      terrainMaterial.uniforms.colorPeak.value = theme.colorPeak;
      terrainMaterial.uniforms.sliceColor.value = theme.sliceColor;
      terrainMaterial.uniforms.gridColor.value = theme.gridColor;
      terrainMaterial.uniforms.hasRivers = { value: theme.hasRivers ? 1.0 : 0.0 };
      if (theme.riverColor) {
        terrainMaterial.uniforms.riverColor = { value: theme.riverColor };
      }

      // Update volume colors
      volumeMaterial.uniforms.baseColor.value = theme.volumeBase;
      volumeMaterial.uniforms.gridColor.value = theme.volumeGrid;

      // Update lights
      keyLight.color.setHex(theme.keyLightColor);
      fillLight.color.setHex(theme.fillLightColor);
      ambientLight.color.setHex(theme.ambientColor);

      // Show/hide animals for arctic theme
      animalGroup.visible = theme.showAnimals;

      // Update HUD title
      document.querySelector('.hud-top-left .title').textContent = `◈ ${theme.title}`;

      // Update HUD colors
      document.querySelectorAll('.hud').forEach(hud => {
        hud.style.color = theme.hudColor;
      });
      document.querySelectorAll('.title').forEach(title => {
        title.style.color = theme.hudTitleColor;
      });
      document.querySelectorAll('.label').forEach(label => {
        label.style.color = theme.hudLabelColor;
      });
      document.querySelectorAll('.value').forEach(value => {
        value.style.color = theme.hudValueColor;
      });

      // Update button states
      document.querySelectorAll('.theme-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.theme === themeName) {
          btn.classList.add('active');
        }
      });
    }

    // Theme button handlers
    document.querySelectorAll('.theme-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        applyTheme(btn.dataset.theme);
      });
    });

    // Initialize wall geometries
    updateWallGeometries();

    animate();
  </script>
</body>
</html>
